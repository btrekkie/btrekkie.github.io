<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_201) on Sat May 30 09:57:45 EDT 2020 -->
<title>RedBlackNode</title>
<meta name="date" content="2020-05-30">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="RedBlackNode";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":9,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/RedBlackNode.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/github/btrekkie/red_black_node/RedBlackNode.html" target="_top">Frames</a></li>
<li><a href="RedBlackNode.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">com.github.btrekkie.red_black_node</div>
<h2 title="Class RedBlackNode" class="title">Class RedBlackNode&lt;N extends RedBlackNode&lt;N&gt;&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.github.btrekkie.red_black_node.RedBlackNode&lt;N&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>N</code> - The type of node in the tree. For example, we might have
     "class FooNode<T> extends RedBlackNode<FooNode<T>>".</dd>
</dl>
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.lang.Comparable&lt;N&gt;</dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">RedBlackNode&lt;N extends RedBlackNode&lt;N&gt;&gt;</span>
extends java.lang.Object
implements java.lang.Comparable&lt;N&gt;</pre>
<div class="block">A node in a red-black tree ( https://en.wikipedia.org/wiki/Red%E2%80%93black_tree ). Compared to a class like Java's
 TreeMap, RedBlackNode is a low-level data structure. The internals of a node are exposed as public fields, allowing
 clients to directly observe and manipulate the structure of the tree. This gives clients flexibility, although it
 also enables them to violate the red-black or BST properties. The RedBlackNode class provides methods for performing
 various standard operations, such as insertion and removal.

 Unlike most implementations of binary search trees, RedBlackNode supports arbitrary augmentation. By subclassing
 RedBlackNode, clients can add arbitrary data and augmentation information to each node. For example, if we were to
 use a RedBlackNode subclass to implement a sorted set, the subclass would have a field storing an element in the set.
 If we wanted to keep track of the number of non-leaf nodes in each subtree, we would store this as a "size" field and
 override augment() to update this field. All RedBlackNode methods (such as "insert" and remove()) call augment() as
 necessary to correctly maintain the augmentation information, unless otherwise indicated.

 The values of the tree are stored in the non-leaf nodes. RedBlackNode does not support use cases where values must be
 stored in the leaf nodes. It is recommended that all of the leaf nodes in a given tree be the same (black)
 RedBlackNode instance, to save space. The root of an empty tree is a leaf node, as opposed to null.

 For reference, a red-black tree is a binary search tree satisfying the following properties:

 - Every node is colored red or black.
 - The leaf nodes, which are dummy nodes that do not store any values, are colored black.
 - The root is black.
 - Both children of each red node are black.
 - Every path from the root to a leaf contains the same number of black nodes.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Bill Jacobs</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#isRed">isRed</a></span></code>
<div class="block">Whether the node is colored red, as opposed to black.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#left">left</a></span></code>
<div class="block">The left child of this node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#parent">parent</a></span></code>
<div class="block">The parent of this node, if any.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#right">right</a></span></code>
<div class="block">The right child of this node.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#RedBlackNode--">RedBlackNode</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#assertNodeIsValid--">assertNodeIsValid</a></span>()</code>
<div class="block">Throws a RuntimeException if we detect that this node locally violates any invariants specific to this subclass
 of RedBlackNode.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#assertOrderIsValid-java.util.Comparator-">assertOrderIsValid</a></span>(java.util.Comparator&lt;? super <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&gt;&nbsp;comparator)</code>
<div class="block">Throws a RuntimeException if the nodes in the subtree rooted at this node are not in the specified order.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#assertSubtreeIsValid--">assertSubtreeIsValid</a></span>()</code>
<div class="block">Throws a RuntimeException if we detect a problem with the subtree rooted at this node, such as a red child of a
 red node or a non-leaf descendant "node" for which node.left.parent != node.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#assertSubtreeIsValidRedBlack--">assertSubtreeIsValidRedBlack</a></span>()</code>
<div class="block">Throws a RuntimeException if the subtree rooted at this node is not a valid red-black tree, e.g.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#augment--">augment</a></span>()</code>
<div class="block">Sets any augmentation information about the subtree rooted at this node that is stored in this node.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#compareTo-N-">compareTo</a></span>(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;other)</code>
<div class="block">Returns an integer comparing the position of this node in the tree that contains it with that of "other".</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#concatenate-N-">concatenate</a></span>(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;last)</code>
<div class="block">Concatenates the tree rooted at "last" to the end of the tree rooted at this node.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#concatenate-N-N-">concatenate</a></span>(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;last,
           <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;pivot)</code>
<div class="block">Concatenates to the end of the tree rooted at this node.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static &lt;N extends <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="class in com.github.btrekkie.red_black_node">RedBlackNode</a>&lt;N&gt;&gt;<br>N</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#createTree-java.util.Collection-N-">createTree</a></span>(java.util.Collection&lt;? extends N&gt;&nbsp;nodes,
          N&nbsp;leaf)</code>
<div class="block">Returns the root of a perfectly height-balanced tree containing the specified nodes, in iteration order.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#fixInsertion--">fixInsertion</a></span>()</code>
<div class="block">Performs red-black insertion fixup.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#fixInsertion-boolean-">fixInsertion</a></span>(boolean&nbsp;augment)</code>
<div class="block">Performs red-black insertion fixup.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#fixInsertionWithoutGettingRoot--">fixInsertionWithoutGettingRoot</a></span>()</code>
<div class="block">Performs red-black insertion fixup.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#fixInsertionWithoutGettingRoot-boolean-">fixInsertionWithoutGettingRoot</a></span>(boolean&nbsp;augment)</code>
<div class="block">Performs red-black insertion fixup.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#insert-N-boolean-java.util.Comparator-">insert</a></span>(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;newNode,
      boolean&nbsp;allowDuplicates,
      java.util.Comparator&lt;? super <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&gt;&nbsp;comparator)</code>
<div class="block">Inserts the specified node into the tree rooted at this node.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#isLeaf--">isLeaf</a></span>()</code>
<div class="block">Returns whether this is a leaf node.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#lca-N-">lca</a></span>(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;other)</code>
<div class="block">Returns the lowest common ancestor of this node and "other" - the node that is an ancestor of both and is not the
 parent of a node that is an ancestor of both.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#max--">max</a></span>()</code>
<div class="block">Returns the last node in the subtree rooted at this node, if any.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#min--">min</a></span>()</code>
<div class="block">Returns the first node in the subtree rooted at this node, if any.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#predecessor--">predecessor</a></span>()</code>
<div class="block">Returns the node immediately before this in the tree that contains this node, if any.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#remove--">remove</a></span>()</code>
<div class="block">Removes this node from the tree that contains it.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#removeWithoutGettingRoot--">removeWithoutGettingRoot</a></span>()</code>
<div class="block">Removes this node from the tree that contains it.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#root--">root</a></span>()</code>
<div class="block">Returns the root of the tree that contains this node.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#rotateLeft--">rotateLeft</a></span>()</code>
<div class="block">Performs a left rotation about this node.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#rotateRight--">rotateRight</a></span>()</code>
<div class="block">Performs a right rotation about this node.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#split-N-">split</a></span>(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;splitNode)</code>
<div class="block">Splits the tree rooted at this node into two trees, so that the first element of the return value is the root of
 a tree consisting of the nodes that were before the specified node, and the second element of the return value is
 the root of a tree consisting of the nodes that were equal to or after the specified node.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html#successor--">successor</a></span>()</code>
<div class="block">Returns the node immediately after this in the tree that contains this node, if any.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="parent">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parent</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a> extends <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="class in com.github.btrekkie.red_black_node">RedBlackNode</a>&lt;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&gt; parent</pre>
<div class="block">The parent of this node, if any.  "parent" is null if this is a leaf node.</div>
</li>
</ul>
<a name="left">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>left</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a> extends <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="class in com.github.btrekkie.red_black_node">RedBlackNode</a>&lt;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&gt; left</pre>
<div class="block">The left child of this node.  "left" is null if this is a leaf node.</div>
</li>
</ul>
<a name="right">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>right</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a> extends <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="class in com.github.btrekkie.red_black_node">RedBlackNode</a>&lt;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&gt; right</pre>
<div class="block">The right child of this node.  "right" is null if this is a leaf node.</div>
</li>
</ul>
<a name="isRed">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>isRed</h4>
<pre>public&nbsp;boolean isRed</pre>
<div class="block">Whether the node is colored red, as opposed to black.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="RedBlackNode--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>RedBlackNode</h4>
<pre>public&nbsp;RedBlackNode()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="augment--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>augment</h4>
<pre>public&nbsp;boolean&nbsp;augment()</pre>
<div class="block">Sets any augmentation information about the subtree rooted at this node that is stored in this node.  For
 example, if we augment each node by subtree size (the number of non-leaf nodes in the subtree), this method would
 set the size field of this node to be equal to the size field of the left child plus the size field of the right
 child plus one.

 "Augmentation information" is information that we can compute about a subtree rooted at some node, preferably
 based only on the augmentation information in the node's two children and the information in the node.  Examples
 of augmentation information are the sum of the values in a subtree and the number of non-leaf nodes in a subtree.
 Augmentation information may not depend on the colors of the nodes.

 This method returns whether the augmentation information in any of the ancestors of this node might have been
 affected by changes in this subtree since the last call to augment().  In the usual case, where the augmentation
 information depends only on the information in this node and the augmentation information in its immediate
 children, this is equivalent to whether the augmentation information changed as a result of this call to
 augment().  For example, in the case of subtree size, this returns whether the value of the size field prior to
 calling augment() differed from the size field of the left child plus the size field of the right child plus one.
 False positives are permitted.  The return value is unspecified if we have not called augment() on this node
 before.

 This method may assume that this is not a leaf node.  It may not assume that the augmentation information stored
 in any of the tree's nodes is correct.  However, if the augmentation information stored in all of the node's
 descendants is correct, then the augmentation information stored in this node must be correct after calling
 augment().</div>
</li>
</ul>
<a name="assertNodeIsValid--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>assertNodeIsValid</h4>
<pre>public&nbsp;void&nbsp;assertNodeIsValid()</pre>
<div class="block">Throws a RuntimeException if we detect that this node locally violates any invariants specific to this subclass
 of RedBlackNode.  For example, if this stores the size of the subtree rooted at this node, this should throw a
 RuntimeException if the size field of this is not equal to the size field of the left child plus the size field
 of the right child plus one.  Note that we may call this on a leaf node.

 assertSubtreeIsValid() calls assertNodeIsValid() on each node, or at least starts to do so until it detects a
 problem.  assertNodeIsValid() should assume the node is in a tree that satisfies all properties common to all
 red-black trees, as assertSubtreeIsValid() is responsible for such checks.  assertNodeIsValid() should be
 "downward-looking", i.e. it should ignore any information in "parent", and it should be "local", i.e. it should
 only check a constant number of descendants.  To include "global" checks, such as verifying the BST property
 concerning ordering, override assertSubtreeIsValid().  assertOrderIsValid is useful for checking the BST
 property.</div>
</li>
</ul>
<a name="isLeaf--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isLeaf</h4>
<pre>public&nbsp;boolean&nbsp;isLeaf()</pre>
<div class="block">Returns whether this is a leaf node.</div>
</li>
</ul>
<a name="root--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>root</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;root()</pre>
<div class="block">Returns the root of the tree that contains this node.</div>
</li>
</ul>
<a name="min--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>min</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;min()</pre>
<div class="block">Returns the first node in the subtree rooted at this node, if any.</div>
</li>
</ul>
<a name="max--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>max</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;max()</pre>
<div class="block">Returns the last node in the subtree rooted at this node, if any.</div>
</li>
</ul>
<a name="predecessor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>predecessor</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;predecessor()</pre>
<div class="block">Returns the node immediately before this in the tree that contains this node, if any.</div>
</li>
</ul>
<a name="successor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>successor</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;successor()</pre>
<div class="block">Returns the node immediately after this in the tree that contains this node, if any.</div>
</li>
</ul>
<a name="rotateLeft--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotateLeft</h4>
<pre>public&nbsp;boolean&nbsp;rotateLeft()</pre>
<div class="block">Performs a left rotation about this node. This method assumes that !isLeaf() && !right.isLeaf(). It calls
 augment() on this node and on its resulting parent. However, it does not call augment() on any of the resulting
 parent's ancestors, because that is normally the responsibility of the caller.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The return value from calling augment() on the resulting parent.</dd>
</dl>
</li>
</ul>
<a name="rotateRight--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotateRight</h4>
<pre>public&nbsp;boolean&nbsp;rotateRight()</pre>
<div class="block">Performs a right rotation about this node. This method assumes that !isLeaf() && !left.isLeaf(). It calls
 augment() on this node and on its resulting parent. However, it does not call augment() on any of the resulting
 parent's ancestors, because that is normally the responsibility of the caller.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The return value from calling augment() on the resulting parent.</dd>
</dl>
</li>
</ul>
<a name="fixInsertionWithoutGettingRoot-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fixInsertionWithoutGettingRoot</h4>
<pre>public&nbsp;void&nbsp;fixInsertionWithoutGettingRoot(boolean&nbsp;augment)</pre>
<div class="block">Performs red-black insertion fixup.  To be more precise, this fixes a tree that satisfies all of the requirements
 of red-black trees, except that this may be a red child of a red node, and if this is the root, the root may be
 red.  node.isRed must initially be true.  This method assumes that this is not a leaf node.  The method performs
 any rotations by calling rotateLeft() and rotateRight().  This method is more efficient than fixInsertion if
 "augment" is false or augment() might return false.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>augment</code> - Whether to set the augmentation information for "node" and its ancestors, by calling augment().</dd>
</dl>
</li>
</ul>
<a name="fixInsertionWithoutGettingRoot--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fixInsertionWithoutGettingRoot</h4>
<pre>public&nbsp;void&nbsp;fixInsertionWithoutGettingRoot()</pre>
<div class="block">Performs red-black insertion fixup.  To be more precise, this fixes a tree that satisfies all of the requirements
 of red-black trees, except that this may be a red child of a red node, and if this is the root, the root may be
 red.  node.isRed must initially be true.  This method assumes that this is not a leaf node.  The method performs
 any rotations by calling rotateLeft() and rotateRight().  This method is more efficient than fixInsertion() if
 augment() might return false.</div>
</li>
</ul>
<a name="fixInsertion-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fixInsertion</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;fixInsertion(boolean&nbsp;augment)</pre>
<div class="block">Performs red-black insertion fixup.  To be more precise, this fixes a tree that satisfies all of the requirements
 of red-black trees, except that this may be a red child of a red node, and if this is the root, the root may be
 red.  node.isRed must initially be true.  This method assumes that this is not a leaf node.  The method performs
 any rotations by calling rotateLeft() and rotateRight().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>augment</code> - Whether to set the augmentation information for "node" and its ancestors, by calling augment().</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The root of the resulting tree.</dd>
</dl>
</li>
</ul>
<a name="fixInsertion--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fixInsertion</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;fixInsertion()</pre>
<div class="block">Performs red-black insertion fixup.  To be more precise, this fixes a tree that satisfies all of the requirements
 of red-black trees, except that this may be a red child of a red node, and if this is the root, the root may be
 red.  node.isRed must initially be true.  This method assumes that this is not a leaf node.  The method performs
 any rotations by calling rotateLeft() and rotateRight().</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The root of the resulting tree.</dd>
</dl>
</li>
</ul>
<a name="insert-com.github.btrekkie.red_black_node.RedBlackNode-boolean-java.util.Comparator-">
<!--   -->
</a><a name="insert-N-boolean-java.util.Comparator-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insert</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;insert(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;newNode,
                boolean&nbsp;allowDuplicates,
                java.util.Comparator&lt;? super <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&gt;&nbsp;comparator)</pre>
<div class="block">Inserts the specified node into the tree rooted at this node. Assumes this is the root. We treat newNode as a
 solitary node that does not belong to any tree, and we ignore its initial "parent", "left", "right", and isRed
 fields.

 If it is not efficient or convenient to find the location for a node using a Comparator, then you should manually
 add the node to the appropriate location, color it red, and call fixInsertion().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newNode</code> - The node to insert.</dd>
<dd><code>allowDuplicates</code> - Whether to insert newNode if there is an equal node in the tree. To check whether we
     inserted newNode, check whether newNode.parent is null and the return value differs from newNode.</dd>
<dd><code>comparator</code> - A comparator indicating where to put the node. If this is null, we use the nodes' natural
     order, as in N.compareTo. If you are passing null, then you must override the compareTo method, because the
     default implementation requires the nodes to already be in the same tree.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The root of the resulting tree.</dd>
</dl>
</li>
</ul>
<a name="removeWithoutGettingRoot--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeWithoutGettingRoot</h4>
<pre>public&nbsp;void&nbsp;removeWithoutGettingRoot()</pre>
<div class="block">Removes this node from the tree that contains it.  The effect of this method on the fields of this node is
 unspecified.  This method assumes that this is not a leaf node.  This method is more efficient than remove() if
 augment() might return false.

 If the node has two children, we begin by moving the node's successor to its former position, by changing the
 successor's "left", "right", "parent", and isRed fields.</div>
</li>
</ul>
<a name="remove--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remove</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;remove()</pre>
<div class="block">Removes this node from the tree that contains it.  The effect of this method on the fields of this node is
 unspecified.  This method assumes that this is not a leaf node.

 If the node has two children, we begin by moving the node's successor to its former position, by changing the
 successor's "left", "right", "parent", and isRed fields.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The root of the resulting tree.</dd>
</dl>
</li>
</ul>
<a name="createTree-java.util.Collection-com.github.btrekkie.red_black_node.RedBlackNode-">
<!--   -->
</a><a name="createTree-java.util.Collection-N-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createTree</h4>
<pre>public static&nbsp;&lt;N extends <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="class in com.github.btrekkie.red_black_node">RedBlackNode</a>&lt;N&gt;&gt;&nbsp;N&nbsp;createTree(java.util.Collection&lt;? extends N&gt;&nbsp;nodes,
                                                       N&nbsp;leaf)</pre>
<div class="block">Returns the root of a perfectly height-balanced tree containing the specified nodes, in iteration order. This
 method is responsible for setting the "left", "right", "parent", and isRed fields of the nodes (excluding
 "leaf"), and calling augment() as appropriate. It ignores the initial values of the "left", "right", "parent",
 and isRed fields.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nodes</code> - The nodes.</dd>
<dd><code>leaf</code> - The leaf node.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The root of the tree.</dd>
</dl>
</li>
</ul>
<a name="concatenate-com.github.btrekkie.red_black_node.RedBlackNode-com.github.btrekkie.red_black_node.RedBlackNode-">
<!--   -->
</a><a name="concatenate-N-N-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatenate</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;concatenate(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;last,
                     <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;pivot)</pre>
<div class="block">Concatenates to the end of the tree rooted at this node.  To be precise, given that all of the nodes in this
 precede the node "pivot", which precedes all of the nodes in "last", this returns the root of a tree containing
 all of these nodes.  This method destroys the trees rooted at "this" and "last".  We treat "pivot" as a solitary
 node that does not belong to any tree, and we ignore its initial "parent", "left", "right", and isRed fields.
 This method assumes that this node and "last" are the roots of their respective trees.

 This method takes O(log N) time.  It is more efficient than inserting "pivot" and then calling concatenate(last).
 It is considerably more efficient than inserting "pivot" and all of the nodes in "last".</div>
</li>
</ul>
<a name="concatenate-com.github.btrekkie.red_black_node.RedBlackNode-">
<!--   -->
</a><a name="concatenate-N-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatenate</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;concatenate(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;last)</pre>
<div class="block">Concatenates the tree rooted at "last" to the end of the tree rooted at this node.  To be precise, given that all
 of the nodes in this precede all of the nodes in "last", this returns the root of a tree containing all of these
 nodes.  This method destroys the trees rooted at "this" and "last".  It assumes that this node and "last" are the
 roots of their respective trees.  This method takes O(log N) time.  It is considerably more efficient than
 inserting all of the nodes in "last".</div>
</li>
</ul>
<a name="split-com.github.btrekkie.red_black_node.RedBlackNode-">
<!--   -->
</a><a name="split-N-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>split</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>[]&nbsp;split(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;splitNode)</pre>
<div class="block">Splits the tree rooted at this node into two trees, so that the first element of the return value is the root of
 a tree consisting of the nodes that were before the specified node, and the second element of the return value is
 the root of a tree consisting of the nodes that were equal to or after the specified node. This method is
 destructive, meaning it does not preserve the original tree. It assumes that this node is the root and is in the
 same tree as splitNode. It takes O(log N) time. It is considerably more efficient than removing all of the
 nodes at or after splitNode and then creating a new tree from those nodes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>The</code> - node at which to split the tree.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array consisting of the resulting trees.</dd>
</dl>
</li>
</ul>
<a name="lca-com.github.btrekkie.red_black_node.RedBlackNode-">
<!--   -->
</a><a name="lca-N-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lca</h4>
<pre>public&nbsp;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;lca(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;other)</pre>
<div class="block">Returns the lowest common ancestor of this node and "other" - the node that is an ancestor of both and is not the
 parent of a node that is an ancestor of both. Assumes that this is in the same tree as "other". Assumes that
 neither "this" nor "other" is a leaf node. This method may return "this" or "other".

 Note that while it is possible to compute the lowest common ancestor in O(P) time, where P is the length of the
 path from this node to "other", the "lca" method is not guaranteed to take O(P) time. If your application
 requires this, then you should write your own lowest common ancestor method.</div>
</li>
</ul>
<a name="compareTo-com.github.btrekkie.red_black_node.RedBlackNode-">
<!--   -->
</a><a name="compareTo-N-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareTo</h4>
<pre>public&nbsp;int&nbsp;compareTo(<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&nbsp;other)</pre>
<div class="block">Returns an integer comparing the position of this node in the tree that contains it with that of "other". Returns
 a negative number if this is earlier, a positive number if this is later, and 0 if this is at the same position.
 Assumes that this is in the same tree as "other". Assumes that neither "this" nor "other" is a leaf node.

 The base class's implementation takes O(log N) time. If a RedBlackNode subclass stores a value used to order the
 nodes, then it could override compareTo to compare the nodes' values, which would take O(1) time.

 Note that while it is possible to compare the positions of two nodes in O(P) time, where P is the length of the
 path from this node to "other", the default implementation of compareTo is not guaranteed to take O(P) time. If
 your application requires this, then you should write your own comparison method.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>compareTo</code>&nbsp;in interface&nbsp;<code>java.lang.Comparable&lt;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a> extends <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="class in com.github.btrekkie.red_black_node">RedBlackNode</a>&lt;<a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&gt;&gt;</code></dd>
</dl>
</li>
</ul>
<a name="assertSubtreeIsValidRedBlack--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>assertSubtreeIsValidRedBlack</h4>
<pre>public&nbsp;void&nbsp;assertSubtreeIsValidRedBlack()</pre>
<div class="block">Throws a RuntimeException if the subtree rooted at this node is not a valid red-black tree, e.g. if a red node
 has a red child or it contains a non-leaf node "node" for which node.left.parent != node. (If parent != null,
 it's okay if isRed is true.) This method is useful for debugging. See also assertSubtreeIsValid().</div>
</li>
</ul>
<a name="assertSubtreeIsValid--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>assertSubtreeIsValid</h4>
<pre>public&nbsp;void&nbsp;assertSubtreeIsValid()</pre>
<div class="block">Throws a RuntimeException if we detect a problem with the subtree rooted at this node, such as a red child of a
 red node or a non-leaf descendant "node" for which node.left.parent != node.  This method is useful for
 debugging.  RedBlackNode subclasses may want to override assertSubtreeIsValid() to call assertOrderIsValid.</div>
</li>
</ul>
<a name="assertOrderIsValid-java.util.Comparator-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>assertOrderIsValid</h4>
<pre>public&nbsp;void&nbsp;assertOrderIsValid(java.util.Comparator&lt;? super <a href="../../../../com/github/btrekkie/red_black_node/RedBlackNode.html" title="type parameter in RedBlackNode">N</a>&gt;&nbsp;comparator)</pre>
<div class="block">Throws a RuntimeException if the nodes in the subtree rooted at this node are not in the specified order.
 Assumes that this is a valid binary tree, i.e. there are no repeated nodes other than leaf nodes.  This method is
 useful for debugging.  RedBlackNode subclasses may want to override assertSubtreeIsValid() to call
 assertOrderIsValid.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>comparator</code> - A comparator indicating how the nodes should be ordered.  If this is null, we use the nodes'
     natural order, as in N.compareTo.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/RedBlackNode.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/github/btrekkie/red_black_node/RedBlackNode.html" target="_top">Frames</a></li>
<li><a href="RedBlackNode.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
