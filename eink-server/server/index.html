<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>eink.server API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eink.server</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .errors import ServerError
from .server import Server
from .simulator import Simulator

__all__ = [&#39;Server&#39;, &#39;ServerError&#39;, &#39;Simulator&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="eink.server.errors" href="errors.html">eink.server.errors</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="eink.server.server" href="server.html">eink.server.server</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="eink.server.simulator" href="simulator.html">eink.server.simulator</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eink.server.Server"><code class="flex name class">
<span>class <span class="ident">Server</span></span>
</code></dt>
<dd>
<section class="desc"><p>Serves requests to update an e-ink display.</p>
<p><code>Server</code> is an abstract base class. Its basic function is to take
a binary request payload, which is a request from an e-ink device,
and to return a binary response payload containing updated content.
Subclasses must override at least <code>update_time()</code>,
<code>screensaver_time()</code>, and <code>render()</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Server:
    &#34;&#34;&#34;Serves requests to update an e-ink display.

    ``Server`` is an abstract base class. Its basic function is to take
    a binary request payload, which is a request from an e-ink device,
    and to return a binary response payload containing updated content.
    Subclasses must override at least ``update_time()``,
    ``screensaver_time()``, and ``render()``.
    &#34;&#34;&#34;

    # The maximum allowed return value for ``update_time()``,
    # ``screensaver_time()``, and ``retry_times()``: 365 days.
    MAX_TIME = timedelta(days=365)

    # The maximum value that can be stored in a signed 32-bit integer. This is
    # used to represent an infinite amount of time.
    _INT_MAX = 2 ** 31 - 1

    # The maximum number of request times. This is the maximum number of
    # elements in the C++ field ``ClientState.requestTimesDs``. See the
    # comments for that field.
    _MAX_REQUEST_TIMES = 20

    def update_time(self):
        &#34;&#34;&#34;Return the time to wait before making another request to the server.

        This may not exceed 365 days. If the return value is ``None``,
        the e-ink device will never make another request to the server
        (unless rebooted).

        Returns:
            timedelta: The amount of time.
        &#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclasses must implement&#39;)

    def screensaver_time(self):
        &#34;&#34;&#34;Return the amount of time to wait before displaying the screensaver.

        The idea is that if the e-ink device is unable to connect to the
        server for an extended period of time, then its content may
        become so stale that it is no longer worth showing. In this
        case, we display a full-screen &#34;screensaver&#34; image instead. See
        also ``screensaver_name()``.

        The return value may not exceed 365 days. It should be at least
        ``update_time()``. If the return value is ``None``, the e-ink
        device will never display a screensaver.

        Returns:
            timedelta: The amount of time.
        &#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclasses must implement&#39;)

    def render(self):
        &#34;&#34;&#34;Return the ``Image`` for the e-ink device to display.

        This is the (updated) content that we wish to show. The image
        must have the same size as the display, after rotation (as in
        ``ClientConfig.set_rotation``). It may not have an alpha
        channel. We automatically convert it to a 3-bit grayscale image
        using ``EinkGraphics.round``.
        &#34;&#34;&#34;
        raise NotImplementedError(&#39;Subclasses must implement&#39;)

    def retry_times(self):
        &#34;&#34;&#34;Return the times for the client to retry the server.

        After the client receives this response, it will wait
        ``update_time()`` and then query the server for updated content.
        If this request fails, it will wait ``retry_times()[0]`` and
        then query the server again. If this also fails, it will retry
        after ``retry_times()[1]``, then ``retry_times()[2]``, and so
        on. When we reach the end of ``retry_times()``, it will continue
        to retry every ``retry_times()[-1]``.

        If ``update_time()`` is ``None``, then the return value of
        ``retry_times()`` is ignored. The retry times may not exceed 365
        days. A value of ``None`` indicates that we should stop
        retrying.

        There is a limit to the number of retry times the client can
        store. If the return value of ``retry_times()`` exceeds the
        limit (currently 19), we will adjust the retry times as
        appropriate to fit the limit.

        Returns:
            list&lt;timedelta&gt;: The retry intervals.
        &#34;&#34;&#34;
        update_time = self.update_time()
        if update_time is not None:
            return [0.25 * update_time]
        else:
            return [None]

    def screensaver_name(self):
        &#34;&#34;&#34;Return the name of the screensaver image in ``StatusImages``.

        The idea is that if the e-ink device is unable to connect to the
        server for an extended period of time, then its content may
        become so stale that it is no longer worth showing. In this
        case, we display a full-screen &#34;screensaver&#34; image instead.

        The screensaver is not an arbitrary image selected at runtime,
        but rather a reference to an image previously specified at
        compile time. The default return value is ``&#39;connecting&#39;``. See
        the comments for ``StatusImages``.

        It may be desirable to return a randomly selected image, e.g.
        ``random.choice([&#39;sunrise&#39;, &#39;mountain&#39;, &#39;beach&#39;])``.
        &#34;&#34;&#34;
        return &#39;connecting&#39;

    def exec(self, payload):
        &#34;&#34;&#34;Execute a server request.

        This takes a binary request payload, which is a request from an
        e-ink device, and returns a binary response payload containing
        updated content.

        Arguments:
            payload (bytes): The request payload.

        Returns:
            bytes: The response payload.

        Raises:
            ServerError: If we detect that the specified value is not a
                correctly formatted e-ink request payload, or at least
                not one that this version of the library is able to
                handle.
        &#34;&#34;&#34;
        Request.create_from_bytes(payload)
        request_times_ds = self._request_times_ds()
        screensaver_time_ds = self._interval_to_ds(self.screensaver_time())
        screensaver_id = ServerIO.image_id(self.screensaver_name())

        image = self.render()
        if EinkGraphics._has_alpha(image):
            raise ValueError(
                &#39;Server.render() may not return an image with an alpha &#39;
                &#39;channel&#39;)
        image_data = ImageData.render_png(EinkGraphics.round(image))
        response = Response(
            image_data, request_times_ds, screensaver_id, screensaver_time_ds)
        return response.to_bytes()

    def _interval_to_ds(self, interval):
        &#34;&#34;&#34;Convert the specified amount of time to tenths of a second.

        Return the integer number of tenths of a second nearest to the
        specified amount of time. The amount of time must be between 0
        and 365 days. Return ``_INT_MAX`` if ``interval`` is ``None``.

        Arguments:
            interval (timedelta): The amount of time.

        Returns:
            int: The amount of time, in tenths of a second.
        &#34;&#34;&#34;
        if interval is None:
            return Server._INT_MAX
        elif not isinstance(interval, timedelta):
            raise TypeError(&#39;Time intervals must be instances of timedelta&#39;)
        elif interval &lt; timedelta():
            raise ValueError(&#39;Time intervals may not be negative&#39;)
        elif interval &gt; Server.MAX_TIME:
            raise ValueError(&#39;Time intervals may not be greater than 365 days&#39;)
        else:
            return int(10 * interval.total_seconds() + 0.5)

    def _request_times_ds(self):
        &#34;&#34;&#34;Return the request times.

        Return the request times in tenths of a second, as in the C++
        field ``ClientState.requestTimesDs``.
        &#34;&#34;&#34;
        request_times = [self.update_time()] + self.retry_times()
        if len(request_times) &lt;= 1:
            raise ValueError(
                &#39;Server.retry_times() may not return an empty list&#39;)
        request_times_ds = list([
            self._interval_to_ds(time) for time in request_times])
        for index, time_ds in enumerate(request_times_ds):
            if time_ds &gt;= Server._INT_MAX:
                request_times_ds = request_times_ds[:index + 1]
                break

        if len(request_times_ds) &gt; Server._MAX_REQUEST_TIMES:
            request_times_ds = (
                request_times_ds[:Server._MAX_REQUEST_TIMES - 1] +
                [request_times_ds[-1]])
        return request_times_ds</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="eink.server.Server.MAX_TIME"><code class="name">var <span class="ident">MAX_TIME</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eink.server.Server.exec"><code class="name flex">
<span>def <span class="ident">exec</span></span>(<span>self, payload)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute a server request.</p>
<p>This takes a binary request payload, which is a request from an
e-ink device, and returns a binary response payload containing
updated content.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>payload</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The request payload.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bytes</code></strong></dt>
<dd>The response payload.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><a title="eink.server.ServerError" href="#eink.server.ServerError"><code>ServerError</code></a></strong></dt>
<dd>If we detect that the specified value is not a
correctly formatted e-ink request payload, or at least
not one that this version of the library is able to
handle.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exec(self, payload):
    &#34;&#34;&#34;Execute a server request.

    This takes a binary request payload, which is a request from an
    e-ink device, and returns a binary response payload containing
    updated content.

    Arguments:
        payload (bytes): The request payload.

    Returns:
        bytes: The response payload.

    Raises:
        ServerError: If we detect that the specified value is not a
            correctly formatted e-ink request payload, or at least
            not one that this version of the library is able to
            handle.
    &#34;&#34;&#34;
    Request.create_from_bytes(payload)
    request_times_ds = self._request_times_ds()
    screensaver_time_ds = self._interval_to_ds(self.screensaver_time())
    screensaver_id = ServerIO.image_id(self.screensaver_name())

    image = self.render()
    if EinkGraphics._has_alpha(image):
        raise ValueError(
            &#39;Server.render() may not return an image with an alpha &#39;
            &#39;channel&#39;)
    image_data = ImageData.render_png(EinkGraphics.round(image))
    response = Response(
        image_data, request_times_ds, screensaver_id, screensaver_time_ds)
    return response.to_bytes()</code></pre>
</details>
</dd>
<dt id="eink.server.Server.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the <code>Image</code> for the e-ink device to display.</p>
<p>This is the (updated) content that we wish to show. The image
must have the same size as the display, after rotation (as in
<code>ClientConfig.set_rotation</code>). It may not have an alpha
channel. We automatically convert it to a 3-bit grayscale image
using <code>EinkGraphics.round</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self):
    &#34;&#34;&#34;Return the ``Image`` for the e-ink device to display.

    This is the (updated) content that we wish to show. The image
    must have the same size as the display, after rotation (as in
    ``ClientConfig.set_rotation``). It may not have an alpha
    channel. We automatically convert it to a 3-bit grayscale image
    using ``EinkGraphics.round``.
    &#34;&#34;&#34;
    raise NotImplementedError(&#39;Subclasses must implement&#39;)</code></pre>
</details>
</dd>
<dt id="eink.server.Server.retry_times"><code class="name flex">
<span>def <span class="ident">retry_times</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the times for the client to retry the server.</p>
<p>After the client receives this response, it will wait
<code>update_time()</code> and then query the server for updated content.
If this request fails, it will wait <code>retry_times()[0]</code> and
then query the server again. If this also fails, it will retry
after <code>retry_times()[1]</code>, then <code>retry_times()[2]</code>, and so
on. When we reach the end of <code>retry_times()</code>, it will continue
to retry every <code>retry_times()[-1]</code>.</p>
<p>If <code>update_time()</code> is <code>None</code>, then the return value of
<code>retry_times()</code> is ignored. The retry times may not exceed 365
days. A value of <code>None</code> indicates that we should stop
retrying.</p>
<p>There is a limit to the number of retry times the client can
store. If the return value of <code>retry_times()</code> exceeds the
limit (currently 19), we will adjust the retry times as
appropriate to fit the limit.</p>
<h2 id="returns">Returns</h2>
<p>list<timedelta>: The retry intervals.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry_times(self):
    &#34;&#34;&#34;Return the times for the client to retry the server.

    After the client receives this response, it will wait
    ``update_time()`` and then query the server for updated content.
    If this request fails, it will wait ``retry_times()[0]`` and
    then query the server again. If this also fails, it will retry
    after ``retry_times()[1]``, then ``retry_times()[2]``, and so
    on. When we reach the end of ``retry_times()``, it will continue
    to retry every ``retry_times()[-1]``.

    If ``update_time()`` is ``None``, then the return value of
    ``retry_times()`` is ignored. The retry times may not exceed 365
    days. A value of ``None`` indicates that we should stop
    retrying.

    There is a limit to the number of retry times the client can
    store. If the return value of ``retry_times()`` exceeds the
    limit (currently 19), we will adjust the retry times as
    appropriate to fit the limit.

    Returns:
        list&lt;timedelta&gt;: The retry intervals.
    &#34;&#34;&#34;
    update_time = self.update_time()
    if update_time is not None:
        return [0.25 * update_time]
    else:
        return [None]</code></pre>
</details>
</dd>
<dt id="eink.server.Server.screensaver_name"><code class="name flex">
<span>def <span class="ident">screensaver_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the name of the screensaver image in <code>StatusImages</code>.</p>
<p>The idea is that if the e-ink device is unable to connect to the
server for an extended period of time, then its content may
become so stale that it is no longer worth showing. In this
case, we display a full-screen "screensaver" image instead.</p>
<p>The screensaver is not an arbitrary image selected at runtime,
but rather a reference to an image previously specified at
compile time. The default return value is <code>'connecting'</code>. See
the comments for <code>StatusImages</code>.</p>
<p>It may be desirable to return a randomly selected image, e.g.
<code>random.choice(['sunrise', 'mountain', 'beach'])</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def screensaver_name(self):
    &#34;&#34;&#34;Return the name of the screensaver image in ``StatusImages``.

    The idea is that if the e-ink device is unable to connect to the
    server for an extended period of time, then its content may
    become so stale that it is no longer worth showing. In this
    case, we display a full-screen &#34;screensaver&#34; image instead.

    The screensaver is not an arbitrary image selected at runtime,
    but rather a reference to an image previously specified at
    compile time. The default return value is ``&#39;connecting&#39;``. See
    the comments for ``StatusImages``.

    It may be desirable to return a randomly selected image, e.g.
    ``random.choice([&#39;sunrise&#39;, &#39;mountain&#39;, &#39;beach&#39;])``.
    &#34;&#34;&#34;
    return &#39;connecting&#39;</code></pre>
</details>
</dd>
<dt id="eink.server.Server.screensaver_time"><code class="name flex">
<span>def <span class="ident">screensaver_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the amount of time to wait before displaying the screensaver.</p>
<p>The idea is that if the e-ink device is unable to connect to the
server for an extended period of time, then its content may
become so stale that it is no longer worth showing. In this
case, we display a full-screen "screensaver" image instead. See
also <code>screensaver_name()</code>.</p>
<p>The return value may not exceed 365 days. It should be at least
<code>update_time()</code>. If the return value is <code>None</code>, the e-ink
device will never display a screensaver.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>timedelta</code></strong></dt>
<dd>The amount of time.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def screensaver_time(self):
    &#34;&#34;&#34;Return the amount of time to wait before displaying the screensaver.

    The idea is that if the e-ink device is unable to connect to the
    server for an extended period of time, then its content may
    become so stale that it is no longer worth showing. In this
    case, we display a full-screen &#34;screensaver&#34; image instead. See
    also ``screensaver_name()``.

    The return value may not exceed 365 days. It should be at least
    ``update_time()``. If the return value is ``None``, the e-ink
    device will never display a screensaver.

    Returns:
        timedelta: The amount of time.
    &#34;&#34;&#34;
    raise NotImplementedError(&#39;Subclasses must implement&#39;)</code></pre>
</details>
</dd>
<dt id="eink.server.Server.update_time"><code class="name flex">
<span>def <span class="ident">update_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the time to wait before making another request to the server.</p>
<p>This may not exceed 365 days. If the return value is <code>None</code>,
the e-ink device will never make another request to the server
(unless rebooted).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>timedelta</code></strong></dt>
<dd>The amount of time.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_time(self):
    &#34;&#34;&#34;Return the time to wait before making another request to the server.

    This may not exceed 365 days. If the return value is ``None``,
    the e-ink device will never make another request to the server
    (unless rebooted).

    Returns:
        timedelta: The amount of time.
    &#34;&#34;&#34;
    raise NotImplementedError(&#39;Subclasses must implement&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eink.server.ServerError"><code class="flex name class">
<span>class <span class="ident">ServerError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Indicates that we detected an invalid request payload.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerError(Exception):
    &#34;&#34;&#34;Indicates that we detected an invalid request payload.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="eink.server.Simulator"><code class="flex name class">
<span>class <span class="ident">Simulator</span></span>
</code></dt>
<dd>
<section class="desc"><p>Provides the ability to simulate a request to a server.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulator:
    &#34;&#34;&#34;Provides the ability to simulate a request to a server.&#34;&#34;&#34;

    @staticmethod
    def connect(url):
        &#34;&#34;&#34;Return the image returned when requesting the specified URL.

        This should be the URL of an e-ink server. The image indicates
        the content that the server is instructing the e-ink device to
        display.

        Arguments:
            url (str): The URL.

        Returns:
            Image: The image.
        &#34;&#34;&#34;
        request_payload = Request().to_bytes()
        url_request = urllib.request.Request(
            url, data=request_payload,
            headers={&#39;Content-Type&#39;: &#39;application/octet-stream&#39;},
            method=&#39;POST&#39;)
        with urllib.request.urlopen(url_request) as url_response:
            response_payload = url_response.read()
        response = Response.create_from_bytes(response_payload)
        return Image.open(io.BytesIO(response.image_data))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="eink.server.Simulator.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>url)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the image returned when requesting the specified URL.</p>
<p>This should be the URL of an e-ink server. The image indicates
the content that the server is instructing the e-ink device to
display.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Image</code></strong></dt>
<dd>The image.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def connect(url):
    &#34;&#34;&#34;Return the image returned when requesting the specified URL.

    This should be the URL of an e-ink server. The image indicates
    the content that the server is instructing the e-ink device to
    display.

    Arguments:
        url (str): The URL.

    Returns:
        Image: The image.
    &#34;&#34;&#34;
    request_payload = Request().to_bytes()
    url_request = urllib.request.Request(
        url, data=request_payload,
        headers={&#39;Content-Type&#39;: &#39;application/octet-stream&#39;},
        method=&#39;POST&#39;)
    with urllib.request.urlopen(url_request) as url_response:
        response_payload = url_response.read()
    response = Response.create_from_bytes(response_payload)
    return Image.open(io.BytesIO(response.image_data))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eink" href="../index.html">eink</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="eink.server.errors" href="errors.html">eink.server.errors</a></code></li>
<li><code><a title="eink.server.server" href="server.html">eink.server.server</a></code></li>
<li><code><a title="eink.server.simulator" href="simulator.html">eink.server.simulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eink.server.Server" href="#eink.server.Server">Server</a></code></h4>
<ul class="two-column">
<li><code><a title="eink.server.Server.MAX_TIME" href="#eink.server.Server.MAX_TIME">MAX_TIME</a></code></li>
<li><code><a title="eink.server.Server.exec" href="#eink.server.Server.exec">exec</a></code></li>
<li><code><a title="eink.server.Server.render" href="#eink.server.Server.render">render</a></code></li>
<li><code><a title="eink.server.Server.retry_times" href="#eink.server.Server.retry_times">retry_times</a></code></li>
<li><code><a title="eink.server.Server.screensaver_name" href="#eink.server.Server.screensaver_name">screensaver_name</a></code></li>
<li><code><a title="eink.server.Server.screensaver_time" href="#eink.server.Server.screensaver_time">screensaver_time</a></code></li>
<li><code><a title="eink.server.Server.update_time" href="#eink.server.Server.update_time">update_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eink.server.ServerError" href="#eink.server.ServerError">ServerError</a></code></h4>
</li>
<li>
<h4><code><a title="eink.server.Simulator" href="#eink.server.Simulator">Simulator</a></code></h4>
<ul class="">
<li><code><a title="eink.server.Simulator.connect" href="#eink.server.Simulator.connect">connect</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>