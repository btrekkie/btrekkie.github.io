<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>eink.generate API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eink.generate</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .client_code_generator import ClientCodeGenerator
from .client_config import ClientConfig
from .rotation import Rotation
from .server_code_generator import ServerCodeGenerator
from .status_images import StatusImages
from .transport import Transport
from .web_transport import WebTransport

__all__ = [
    &#39;ClientCodeGenerator&#39;, &#39;ClientConfig&#39;, &#39;Rotation&#39;, &#39;ServerCodeGenerator&#39;,
    &#39;StatusImages&#39;, &#39;Transport&#39;, &#39;WebTransport&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="eink.generate.client_code_generator" href="client_code_generator.html">eink.generate.client_code_generator</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="eink.generate.client_config" href="client_config.html">eink.generate.client_config</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="eink.generate.rotation" href="rotation.html">eink.generate.rotation</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="eink.generate.server_code_generator" href="server_code_generator.html">eink.generate.server_code_generator</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="eink.generate.status_images" href="status_images.html">eink.generate.status_images</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="eink.generate.transport" href="transport.html">eink.generate.transport</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="eink.generate.web_transport" href="web_transport.html">eink.generate.web_transport</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eink.generate.ClientCodeGenerator"><code class="flex name class">
<span>class <span class="ident">ClientCodeGenerator</span></span>
</code></dt>
<dd>
<section class="desc"><p>Generates client-side source code for the Inkplate device.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClientCodeGenerator:
    &#34;&#34;&#34;Generates client-side source code for the Inkplate device.&#34;&#34;&#34;

    # The cached return value of _str_literal_list()
    _str_literal_list_cache = None

    @staticmethod
    def gen(config, dir_):
        &#34;&#34;&#34;Generate client-side source code files for the Inkplate device.

        Arguments:
            config (ClientConfig): The configuration for the program.
            dir_ (str): The directory in which to store the resulting
                source code files. This directory must already exist.
        &#34;&#34;&#34;
        ClientCodeGenerator._validate(config, dir_)
        ClientCodeGenerator._copy_static_files(dir_)
        ClientCodeGenerator._gen_dynamic_files(config, dir_)

    @staticmethod
    def _validate(config, dir_):
        &#34;&#34;&#34;Raise if we detect an error in the specified arguments to ``gen``.
        &#34;&#34;&#34;
        if not os.path.isdir(dir_):
            raise OSError(&#39;No such directory {:s}&#39;.format(dir_))
        if not config._transports:
            raise ValueError(&#39;No Transports provided&#39;)
        if not config._wi_fi_networks:
            raise ValueError(&#39;No Wi-Fi networks provided&#39;)

        status_images = config._status_images
        images = status_images._images
        if status_images._initial_image_name not in images:
            raise ValueError(
                &#39;StatusImages is missing the initial image {:s}&#39;.format(
                    status_images._initial_image_name))
        if status_images._low_battery_image_name not in images:
            raise ValueError(
                &#39;StatusImages is missing the low battery image {:s}&#39;.format(
                    status_images._low_battery_image_name))

        for name, image in images.items():
            if (image.width != status_images._width or
                    image.height != status_images._height):
                raise ValueError(
                    &#39;The size of the image {:s} does not match the size &#39;
                    &#39;passed to the StatusImages constructor&#39;.format(name))
            if EinkGraphics._has_alpha(image):
                raise ValueError(
                    &#39;Alpha channels are not supported. The image {:s} has an &#39;
                    &#39;alpha channel.&#39;.format(image))

    @staticmethod
    def _copy_static_files(dir_):
        &#34;&#34;&#34;Copy the static files to the specified directory.

        Copy the source code files for the client that are not generated
        programatically to the specified directory.
        &#34;&#34;&#34;
        client_dir = Project.client_code_dir()
        for subfile in os.listdir(client_dir):
            if subfile == &#39;client.ino&#39;:
                output_subfile = &#39;{:s}.ino&#39;.format(
                    os.path.basename(os.path.abspath(dir_)))
                shutil.copy(
                    os.path.join(client_dir, subfile),
                    os.path.join(dir_, output_subfile))
            elif subfile.endswith((&#39;.cpp&#39;, &#39;.h&#39;, &#39;.ino&#39;)):
                shutil.copy(
                    os.path.join(client_dir, subfile),
                    os.path.join(dir_, subfile))

    @staticmethod
    def _write_bytes_literal(file, bytes_, multiline):
        &#34;&#34;&#34;Write C code for a literal byte array to the specified file.

        Arguments:
            file (file): The file object.
            bytes_ (bytes): The contents of the byte array.
            multiline (bool): Whether to format the results by writing
                line breaks as appropriate.
        &#34;&#34;&#34;
        file.write(&#39;{&#39;)
        if multiline:
            file.write(&#39;\n    &#39;)
            column = 4
        else:
            column = 1

        first = True
        for byte in bytes_:
            if not first:
                if not multiline or column &lt; 73:
                    file.write(&#39;, &#39;)
                    column += 2
                else:
                    file.write(&#39;,\n    &#39;)
                    column = 4
            first = False

            file.write(&#39;0x{:02x}&#39;.format(byte))
            column += 4

        if multiline:
            file.write(&#39;\n&#39;)
        file.write(&#39;}&#39;)

    @staticmethod
    def _str_literal_list():
        r&#34;&#34;&#34;Return a list of literal C string fragments for each character.

        The return value has 256 elements. The (i + 1)th element of the
        return value is for ``chr(i)``. For example, the element for the
        newline character may be ``&#39;\\n&#39;``, while the element for the
        dash character may be ``&#39;-&#39;``. The only escape sequences we use
        are non-numeric escape sequences and three-digit octal escape
        sequences such as ``&#39;\123&#39;``.
        &#34;&#34;&#34;
        if ClientCodeGenerator._str_literal_list_cache is None:
            literal_list = []
            for i in range(0x20):
                literal_list.append(&#39;\\{:03o}&#39;.format(i))
            for i in range(0x20, 0x7f):
                literal_list.append(chr(i))
            for i in range(0x7f, 0x100):
                literal_list.append(&#39;\\{:03o}&#39;.format(i))

            escapes = [
                (&#39;&#34;&#39;, &#39;\\&#34;&#39;), (&#39;\\&#39;, &#39;\\\\&#39;), (&#39;\a&#39;, &#39;\\a&#39;), (&#39;\a&#39;, &#39;\\a&#39;),
                (&#39;\b&#39;, &#39;\\b&#39;), (&#39;\f&#39;, &#39;\\f&#39;), (&#39;\n&#39;, &#39;\\n&#39;), (&#39;\r&#39;, &#39;\\r&#39;),
                (&#39;\t&#39;, &#39;\\t&#39;), (&#39;\v&#39;, &#39;\\v&#39;),
            ]
            for char, escape in escapes:
                literal_list[ord(char)] = escape
            ClientCodeGenerator._str_literal_list_cache = literal_list
        return ClientCodeGenerator._str_literal_list_cache

    @staticmethod
    def _write_str_literal(file, bytes_):
        &#34;&#34;&#34;Write C code for a literal string to the specified file.

        The string is null-terminated.

        Arguments:
            file (file): The file object.
            bytes_ (bytes): The C string.
        &#34;&#34;&#34;
        literal_list = ClientCodeGenerator._str_literal_list()
        file.write(&#39;&#34;&#39;)
        prev_literal = None
        for byte in bytes_:
            literal = literal_list[byte]
            if literal == &#39;?&#39; and prev_literal == &#39;?&#39;:
                # Avoid the possibility of trigraphs
                literal = &#39;\\?&#39;
            file.write(literal)
            prev_literal = literal
        file.write(&#39;&#34;&#39;)

    @staticmethod
    def _write_str_array(file, strs):
        &#34;&#34;&#34;Write C code for a literal string array to the specified file.

        The strings are null-terminated.

        Arguments:
            file (file): The file object.
            strs (list&lt;bytes&gt;): The C strings. An element of ``None`` is
                permitted. We encode such elements as ``NULL``.
        &#34;&#34;&#34;
        if not strs:
            file.write(&#39;{}&#39;)
            return

        file.write(&#39;{\n&#39;)
        first = True
        for str_ in strs:
            if not first:
                file.write(&#39;,\n&#39;)
            first = False
            file.write(&#39;    &#39;)
            if str_ is not None:
                ClientCodeGenerator._write_str_literal(file, str_)
            else:
                file.write(&#39;NULL&#39;)
        file.write(&#39;\n}&#39;)

    @staticmethod
    def _write_int_array(file, values):
        &#34;&#34;&#34;Write C code for a literal ``int`` array to the specified file.

        Arguments:
            file (file): The file object.
            values (list&lt;int&gt;): The integers.
        &#34;&#34;&#34;
        file.write(&#39;{&#39;)
        first = True
        for value in values:
            if not first:
                file.write(&#39;, &#39;)
            first = False
            file.write(&#39;{:d}&#39;.format(value))
        file.write(&#39;}&#39;)

    @staticmethod
    def _write_generated_message(file):
        &#34;&#34;&#34;Write a C comment indicating a file was generated programatically.

        Arguments:
            file (file): The file object to write the comment to.
        &#34;&#34;&#34;
        file.write(
            &#39;// Auto-generated by the Python class &#39;
            &#39;eink.generate.ClientCodeGenerator\n\n&#39;)

    @staticmethod
    def _write_secrets_cpp(file, config):
        &#34;&#34;&#34;Write the contents of the secrets.cpp file.

        This contains all of the information that we would like to keep
        private. We should refrain from committing the file to a
        repository and from opening the file in a text editor.

        Arguments:
            file (file): The file object to write to.
            config (ClientConfig): The configuration for the program.
        &#34;&#34;&#34;
        passwords = []
        for _, password in config._wi_fi_networks:
            if password is not None:
                passwords.append(password.encode())
            else:
                passwords.append(None)

        ClientCodeGenerator._write_generated_message(file)
        if None in passwords:
            file.write(&#39;#include &lt;stddef.h&gt;\n\n&#39;)
        file.write(&#39;#include &#34;secrets_constants.h&#34;\n\n\n&#39;)
        file.write(&#39;const char* WI_FI_PASSWORDS[] = &#39;)
        ClientCodeGenerator._write_str_array(file, passwords)
        file.write(&#39;;\n&#39;)

    @staticmethod
    def _write_status_image_data_h(file, status_images):
        &#34;&#34;&#34;Write the contents of the status_image_data.h file.

        This declares the constants that are provided in
        status_image_data.cpp.

        Arguments:
            file (file): The file object to write to.
            status_images (StatusImages): The status images for the
                program.
        &#34;&#34;&#34;
        ClientCodeGenerator._write_generated_message(file)
        file.write(
            &#39;#ifndef __STATUS_IMAGE_DATA_H__\n&#39;
            &#39;#define __STATUS_IMAGE_DATA_H__\n\n&#39;
            &#39;// The contents of each of the status image files, in the same &#39;
            &#39;order as\n&#39;
            &#39;// STATUS_IMAGE_DATA\n&#39;)
        for index in range(len(status_images._images)):
            file.write(
                &#39;extern const char STATUS_IMAGE_DATA{:d}[];\n&#39;.format(index))

        file.write(
            &#39;\n// The number of bytes in each of the status image files, in &#39;
            &#39;the same order as\n&#39;
            &#39;// STATUS_IMAGE_DATA\n&#39;)
        for index in range(len(status_images._images)):
            file.write(
                &#39;extern const int STATUS_IMAGE_DATA_LENGTH{:d};\n&#39;.format(
                    index))
        file.write(&#39;\n#endif\n&#39;)

    @staticmethod
    def _render_status_image(image, quality):
        &#34;&#34;&#34;Render the specified status image.

        Arguments:
            image (image): The image.
            quality (int): The quality, as in the ``quality`` argument
                to ``StatusImages.set_image``.

        Returns:
            bytes: The contents of the image file for the image.
        &#34;&#34;&#34;
        image = EinkGraphics.round(image)
        png = ImageData.render_png(image, True)
        if quality &lt; 100:
            jpeg = ImageData.render_jpeg(image, quality)
            if len(jpeg) &lt; len(png):
                return jpeg
        return png

    @staticmethod
    def _write_status_image_data_cpp(file, status_images):
        &#34;&#34;&#34;Write the contents of the status_image_data.cpp file.

        This contains the contents and sizes of the image files for the
        status images. We keep these in a separate file in order to
        improve the readability of generated.cpp.

        Arguments:
            file (file): The file object to write to.
            status_images (StatusImages): The status images for the
                program.
        &#34;&#34;&#34;
        ClientCodeGenerator._write_generated_message(file)
        file.write(&#39;#include &#34;status_image_data.h&#34;\n\n&#39;)

        images = []
        for name, image in status_images._images.items():
            quality = status_images._quality[name]
            images.append((ServerIO.image_id(name), image, quality))

        sorted_images = sorted(images, key=lambda image: image[0])
        for index, (_, image, quality) in enumerate(sorted_images):
            image_data = ClientCodeGenerator._render_status_image(
                image, quality)
            file.write(&#39;\n&#39;)
            file.write(
                &#39;const int STATUS_IMAGE_DATA_LENGTH{:d} = {:d};\n&#39;.format(
                    index, len(image_data)))
            file.write(&#39;const char STATUS_IMAGE_DATA{:d}[] = &#39;.format(index))
            ClientCodeGenerator._write_bytes_literal(file, image_data, True)
            file.write(&#39;;\n&#39;)

    @staticmethod
    def _write_generated_h(file, config):
        &#34;&#34;&#34;Write the contents of the generated.h file.

        This ``#includes`` the header files that declare all of the
        generated constants, and it defines all of the constants that
        are defined using ``#define``.

        Arguments:
            file (file): The file object to write to.
            config (ClientConfig): The configuration for the program.
        &#34;&#34;&#34;
        ClientCodeGenerator._write_generated_message(file)
        file.write(
            &#39;#ifndef __GENERATED_H__\n&#39;
            &#39;#define __GENERATED_H__\n\n&#39;
            &#39;#include &#34;generated_constants.h&#34;\n&#39;
            &#39;#include &#34;secrets_constants.h&#34;\n\n\n&#39;)
        file.write(
            &#39;// The maximum number of elements in ClientState.requestTimesDs\n&#39;
            &#39;#define MAX_REQUEST_TIMES {:d}\n\n&#39;.format(
                Server._MAX_REQUEST_TIMES))
        file.write(
            &#39;// The number of bytes in an image ID, as in the return value of &#39;
            &#39;the Python\n&#39;
            &#39;// method ServerIO.image_id\n&#39;
            &#39;#define STATUS_IMAGE_ID_LENGTH {:d}\n\n&#39;.format(
                ServerIO.STATUS_IMAGE_ID_LENGTH))
        file.write(
            &#39;// The number of elements in the return value of &#39;
            &#39;requestTransports()\n&#39;
            &#39;#define TRANSPORT_COUNT {:d}\n\n&#39;.format(len(config._transports)))
        file.write(&#39;#endif\n&#39;)

    @staticmethod
    def _write_status_images(file, status_images):
        &#34;&#34;&#34;Write the portion of the generated.cpp file for status images.

        Arguments:
            file (file): The file object to write to.
            status_images (StatusImages): The status images for the
                program.
        &#34;&#34;&#34;
        image_id_to_name = {}
        for name in status_images._images.keys():
            image_id_to_name[ServerIO.image_id(name)] = name
        sorted_image_ids = sorted(list(image_id_to_name.keys()))
        image_count = len(sorted_image_ids)
        file.write(
            &#39;const int STATUS_IMAGE_COUNT = {:d};\n&#39;.format(image_count))

        file.write(&#39;const int STATUS_IMAGE_DATA_LENGTHS[] = {\n&#39;)
        for index in range(image_count):
            if index &gt; 0:
                file.write(&#39;,\n&#39;)
            file.write(&#39;    STATUS_IMAGE_DATA_LENGTH{:d}&#39;.format(index))
        file.write(&#39;\n};\n&#39;)

        file.write(&#39;const char* STATUS_IMAGE_DATA[] = {\n&#39;)
        for index in range(image_count):
            if index &gt; 0:
                file.write(&#39;,\n&#39;)
            file.write(&#39;    STATUS_IMAGE_DATA{:d}&#39;.format(index))
        file.write(&#39;\n};\n\n&#39;)

        for index, image_id in enumerate(sorted_image_ids):
            file.write(&#39;const char STATUS_IMAGE_ID{:d}[] = &#39;.format(index))
            ClientCodeGenerator._write_bytes_literal(file, image_id, True)
            file.write(&#39;;\n&#39;)
        file.write(&#39;const char* STATUS_IMAGE_IDS[] = {\n&#39;)
        for index in range(image_count):
            if index &gt; 0:
                file.write(&#39;,\n&#39;)
            file.write(&#39;    STATUS_IMAGE_ID{:d}&#39;.format(index))
        file.write(&#39;\n};\n&#39;)

        # Compute STATUS_IMAGES_BY_TYPE
        image_name_to_index = {}
        for index, image_id in enumerate(sorted_image_ids):
            name = image_id_to_name[image_id]
            image_name_to_index[name] = index
        status_images_by_type = [
            status_images._initial_image_name,
            status_images._low_battery_image_name]
        status_image_indices = []
        for name in status_images_by_type:
            status_image_indices.append(image_name_to_index[name])

        file.write(&#39;const int STATUS_IMAGES_BY_TYPE[] = &#39;)
        ClientCodeGenerator._write_int_array(file, status_image_indices)
        file.write(&#39;;\n&#39;)

    @staticmethod
    def _write_transports(file, transports):
        &#34;&#34;&#34;Write the portion of the generated.cpp file for transports.

        Arguments:
            file (file): The file object to write to.
            transports (list&lt;Transport&gt;): The transports for the
                program, in the order the client should try to connect
                to them.
        &#34;&#34;&#34;
        transport_urls = list([
            transport._url.encode() for transport in transports])
        file.write(&#39;const char* TRANSPORT_URLS[] = &#39;)
        ClientCodeGenerator._write_str_array(file, transport_urls)
        file.write(&#39;;\n&#39;)

    @staticmethod
    def _write_generated_cpp(file, config):
        &#34;&#34;&#34;Write the contents of the generated.cpp file.

        This provides all of the generated constants that don&#39;t have
        some special reason to be provided elsewhere.

        Arguments:
            file (file): The file object to write to.
            config (ClientConfig): The configuration for the program.
        &#34;&#34;&#34;
        ClientCodeGenerator._write_generated_message(file)
        file.write(
            &#39;#include &#34;generated.h&#34;\n&#39;
            &#39;#include &#34;status_image_data.h&#34;\n\n\n&#39;)
        file.write(
            &#39;const int ROTATION = {:d};\n&#39;.format(config._rotation.value))

        file.write(&#39;const char HEADER[] = &#39;)
        ClientCodeGenerator._write_bytes_literal(file, ServerIO.HEADER, True)
        file.write(&#39;;\n&#39;)
        file.write(
            &#39;const int HEADER_LENGTH = {:d};\n&#39;.format(len(ServerIO.HEADER)))

        file.write(&#39;const char PROTOCOL_VERSION[] = &#39;)
        ClientCodeGenerator._write_str_literal(file, ServerIO.PROTOCOL_VERSION)
        file.write(&#39;;\n&#39;)
        file.write(
            &#39;const int PROTOCOL_VERSION_LENGTH = {:d};\n\n&#39;.format(
                len(ServerIO.PROTOCOL_VERSION)))

        ClientCodeGenerator._write_status_images(file, config._status_images)
        file.write(&#39;\n&#39;)
        ClientCodeGenerator._write_transports(file, config._transports)
        file.write(&#39;\n&#39;)

        file.write(
            &#39;const int WI_FI_NETWORK_COUNT = {:d};\n&#39;.format(
                len(config._wi_fi_networks)))

        ssids = list([
            network[0].encode() for network in config._wi_fi_networks])
        file.write(&#39;const char* WI_FI_SSIDS[] = &#39;)
        ClientCodeGenerator._write_str_array(file, ssids)
        file.write(&#39;;\n&#39;)

        networks_with_indices = []
        for index, (ssid, _) in enumerate(config._wi_fi_networks):
            networks_with_indices.append((ssid.encode(), index))
        sorted_networks = sorted(networks_with_indices)
        network_indices = list([network[1] for network in sorted_networks])
        file.write(&#39;const int WI_FI_NETWORK_INDICES[] = &#39;)
        ClientCodeGenerator._write_int_array(file, network_indices)
        file.write(&#39;;\n&#39;)

    @staticmethod
    def _gen_dynamic_files(config, dir_):
        &#34;&#34;&#34;Write the contents of all of the programatically generated files.

        Arguments:
            config (ClientConfig): The configuration for the program.
            dir_ (str): The directory in which to store the files.
        &#34;&#34;&#34;
        # Contains the secret values
        with open(os.path.join(dir_, &#39;secrets.cpp&#39;), &#39;w&#39;) as file:
            ClientCodeGenerator._write_secrets_cpp(file, config)

        # Declares constants for status_image_data.cpp
        with open(os.path.join(dir_, &#39;status_image_data.h&#39;), &#39;w&#39;) as file:
            ClientCodeGenerator._write_status_image_data_h(
                file, config._status_images)

        # Contains the image files for the status images
        with open(os.path.join(dir_, &#39;status_image_data.cpp&#39;), &#39;w&#39;) as file:
            ClientCodeGenerator._write_status_image_data_cpp(
                file, config._status_images)

        # #includes the header files that declare the generated constants, and
        # defines all of the constants that use #define
        with open(os.path.join(dir_, &#39;generated.h&#39;), &#39;w&#39;) as file:
            ClientCodeGenerator._write_generated_h(file, config)

        # Contains the rest of the generated constants
        with open(os.path.join(dir_, &#39;generated.cpp&#39;), &#39;w&#39;) as file:
            ClientCodeGenerator._write_generated_cpp(file, config)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="eink.generate.ClientCodeGenerator.gen"><code class="name flex">
<span>def <span class="ident">gen</span></span>(<span>config, dir_)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate client-side source code files for the Inkplate device.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<a title="eink.generate.ClientConfig" href="#eink.generate.ClientConfig"><code>ClientConfig</code></a></dt>
<dd>The configuration for the program.</dd>
<dt><strong><code>dir_</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory in which to store the resulting
source code files. This directory must already exist.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def gen(config, dir_):
    &#34;&#34;&#34;Generate client-side source code files for the Inkplate device.

    Arguments:
        config (ClientConfig): The configuration for the program.
        dir_ (str): The directory in which to store the resulting
            source code files. This directory must already exist.
    &#34;&#34;&#34;
    ClientCodeGenerator._validate(config, dir_)
    ClientCodeGenerator._copy_static_files(dir_)
    ClientCodeGenerator._gen_dynamic_files(config, dir_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eink.generate.ClientConfig"><code class="flex name class">
<span>class <span class="ident">ClientConfig</span></span>
<span>(</span><span>transport, status_images)</span>
</code></dt>
<dd>
<section class="desc"><p>The configuration information for generating the client's source code.</p>
<p>Initialize a new <code>ClientConfig</code>.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt>transport (Transport|list<Transport>): The server or servers</dt>
<dt>the client should try to connect to. Each time the</dt>
<dt>client tries to fetch updated content, it tries each of</dt>
<dt>the transports in order until it succeeds.</dt>
<dt><strong><a title="eink.generate.status_images" href="status_images.html"><code>eink.generate.status_images</code></a></strong> :&ensp;<a title="eink.generate.StatusImages" href="#eink.generate.StatusImages"><code>StatusImages</code></a></dt>
<dd>The status images. See the
comments for <code>StatusImages</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClientConfig:
    &#34;&#34;&#34;The configuration information for generating the client&#39;s source code.
    &#34;&#34;&#34;

    # Private attributes:
    #
    # Rotation _rotation - The rotation to use when drawing to the Inkplate
    #     device.
    # StatusImages _status_images - The status images. See the comments for
    #     StatusImages.
    # list&lt;Transport&gt; _transports - The servers the client should try to
    #     connect to, in order. Each time the client tries to fetch updated
    #     content, it tries each of the transports in order until it succeeds.
    # list&lt;tuple&lt;str, str&gt;&gt; _wi_fi_networks - The Wi-Fi networks the client may
    #     connect to, in descending order of preference. Each network is
    #     represented as a pair of the SSID and the password, if any.

    def __init__(self, transport, status_images):
        &#34;&#34;&#34;Initialize a new ``ClientConfig``.

        Arguments:
            transport (Transport|list&lt;Transport&gt;): The server or servers
                the client should try to connect to. Each time the
                client tries to fetch updated content, it tries each of
                the transports in order until it succeeds.
            status_images (StatusImages): The status images. See the
                comments for ``StatusImages``.
        &#34;&#34;&#34;
        if isinstance(transport, Transport):
            self._transports = [transport]
        else:
            self._transports = transport
        self._status_images = status_images
        self._wi_fi_networks = []
        self._rotation = Rotation.LANDSCAPE

    def add_wi_fi_network(self, ssid, password):
        &#34;&#34;&#34;Add the specified Wi-Fi network to the list of networks.

        Add the specified Wi-Fi network to the list of networks the
        client may connect to. The SSID must be visible. Networks from
        earlier calls to ``add_wi_fi_network`` are connected to in
        preference to networks from later calls.

        Arguments:
            ssid (str): The network&#39;s SSID.
            password (str): The network&#39;s password, if any.
        &#34;&#34;&#34;
        self._wi_fi_networks.append((ssid, password))

    def set_rotation(self, rotation):
        &#34;&#34;&#34;Set the rotation to use when drawing to the Inkplate device.

        The default is ``Rotation.LANDSCAPE``.

        Arguments:
            rotation (Rotation): The rotation.
        &#34;&#34;&#34;
        self._rotation = rotation</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="eink.generate.ClientConfig.add_wi_fi_network"><code class="name flex">
<span>def <span class="ident">add_wi_fi_network</span></span>(<span>self, ssid, password)</span>
</code></dt>
<dd>
<section class="desc"><p>Add the specified Wi-Fi network to the list of networks.</p>
<p>Add the specified Wi-Fi network to the list of networks the
client may connect to. The SSID must be visible. Networks from
earlier calls to <code>add_wi_fi_network</code> are connected to in
preference to networks from later calls.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>ssid</code></strong> :&ensp;<code>str</code></dt>
<dd>The network's SSID.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The network's password, if any.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_wi_fi_network(self, ssid, password):
    &#34;&#34;&#34;Add the specified Wi-Fi network to the list of networks.

    Add the specified Wi-Fi network to the list of networks the
    client may connect to. The SSID must be visible. Networks from
    earlier calls to ``add_wi_fi_network`` are connected to in
    preference to networks from later calls.

    Arguments:
        ssid (str): The network&#39;s SSID.
        password (str): The network&#39;s password, if any.
    &#34;&#34;&#34;
    self._wi_fi_networks.append((ssid, password))</code></pre>
</details>
</dd>
<dt id="eink.generate.ClientConfig.set_rotation"><code class="name flex">
<span>def <span class="ident">set_rotation</span></span>(<span>self, rotation)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the rotation to use when drawing to the Inkplate device.</p>
<p>The default is <code>Rotation.LANDSCAPE</code>.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><a title="eink.generate.rotation" href="rotation.html"><code>eink.generate.rotation</code></a></strong> :&ensp;<a title="eink.generate.Rotation" href="#eink.generate.Rotation"><code>Rotation</code></a></dt>
<dd>The rotation.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rotation(self, rotation):
    &#34;&#34;&#34;Set the rotation to use when drawing to the Inkplate device.

    The default is ``Rotation.LANDSCAPE``.

    Arguments:
        rotation (Rotation): The rotation.
    &#34;&#34;&#34;
    self._rotation = rotation</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eink.generate.Rotation"><code class="flex name class">
<span>class <span class="ident">Rotation</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<section class="desc"><p>A rotation to use when drawing to the Inkplate device.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rotation(Enum):
    &#34;&#34;&#34;A rotation to use when drawing to the Inkplate device.&#34;&#34;&#34;

    # Landscape rotation
    LANDSCAPE = 4

    # Portrait left (bottom of device on left)
    PORTRAIT_LEFT = 3

    # Portrait right (bottom of device on right)
    PORTRAIT_RIGHT = 1

    # Upside down landscape rotation
    LANDSCAPE_UPSIDE_DOWN = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eink.generate.Rotation.LANDSCAPE"><code class="name">var <span class="ident">LANDSCAPE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="eink.generate.Rotation.LANDSCAPE_UPSIDE_DOWN"><code class="name">var <span class="ident">LANDSCAPE_UPSIDE_DOWN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="eink.generate.Rotation.PORTRAIT_LEFT"><code class="name">var <span class="ident">PORTRAIT_LEFT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="eink.generate.Rotation.PORTRAIT_RIGHT"><code class="name">var <span class="ident">PORTRAIT_RIGHT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</dd>
<dt id="eink.generate.ServerCodeGenerator"><code class="flex name class">
<span>class <span class="ident">ServerCodeGenerator</span></span>
</code></dt>
<dd>
<section class="desc"><p>Generates skeleton code for an e-ink server.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerCodeGenerator:
    &#34;&#34;&#34;Generates skeleton code for an e-ink server.&#34;&#34;&#34;

    @staticmethod
    def gen_skeleton():
        &#34;&#34;&#34;Generate skeleton code for an e-ink server.

        We request information about the server using standard input and
        output.
        &#34;&#34;&#34;
        ServerCodeGenerator._gen_skeleton(
            *ServerCodeGenerator._input_skeleton_params())

    @staticmethod
    def _input(prompt, default, validation_func, hidden=False):
        &#34;&#34;&#34;Prompt the user for a string input.

        The basic procedure is something like this:

        * Display the prompt.
        * If nothing is entered, return the default value.
        * Otherwise, validate the value using validation_func.
        * If valid, return the value entered.
        * If invalid, print an error message and repeat.

        However, the ``_input`` method is responsible for the details.

        Arguments:
            prompt (str): Text to present to the user indicating what
                information to enter.
            default (str): The value to return if the user enters the
                empty string. If this is ``None``, then we return
                ``&#39;&#39;``.
            validation_func (callable): A function for validating the
                result. If it raises a ``RuntimeError`` when we pass in
                the value the user entered, then that value is not
                permitted. Such errors should have messages that are
                suitable to display to the user.
            hidden (bool): Whether to hide the user&#39;s input as he enters
                it. This is useful for passwords.

        Returns:
            str: The value the user entered, or the default value.
        &#34;&#34;&#34;
        if default is None:
            default = &#39;&#39;
        if prompt.endswith(&#39;\n&#39;):
            prompt_with_default = &#39;{:s}[{:s}] &#39;.format(prompt, default)
        else:
            prompt_with_default = &#39;{:s} [{:s}] &#39;.format(prompt, default)

        while True:
            if hidden:
                value = getpass.getpass(prompt_with_default)
            else:
                value = input(prompt_with_default)

            if value == &#39;&#39;:
                return default
            elif validation_func is None:
                return value

            try:
                validation_func(value)
            except RuntimeError as error:
                print()
                print(error.message)
                print()
            else:
                return value

    @staticmethod
    def _normalize_filename(filename):
        &#34;&#34;&#34;Equivalent implementation is contractually guaranteed.&#34;&#34;&#34;
        return os.path.abspath(os.path.expanduser(filename))

    @staticmethod
    def _validate_server_dir(dir_):
        &#34;&#34;&#34;Validate the server directory.

        Raise a ``RuntimeError`` if the specified user entry is not a
        valid server directory.

        Arguments:
            dir_ (str): The user entry.
        &#34;&#34;&#34;
        try:
            absolute_dir = ServerCodeGenerator._normalize_filename(dir_)
        except OSError:
            raise RuntimeError(
                &#39;Error normalizing the filename {:s}&#39;.format(dir_))

        parent = os.path.dirname(absolute_dir)
        if not os.path.isdir(parent):
            raise ValueError(
                &#39;The parent folder {:s} does not exist&#39;.format(parent))

    @staticmethod
    def _validate_client_dir(server_dir, dir_):
        &#34;&#34;&#34;Validate the client directory.

        Raise a ``RuntimeError`` if the specified user entry is not a
        valid client directory.

        Arguments:
            server_dir (str): The server directory.
            dir_ (str): The user entry.
        &#34;&#34;&#34;
        try:
            absolute_dir = ServerCodeGenerator._normalize_filename(dir_)
        except OSError:
            raise RuntimeError(
                &#39;Error normalizing the filename {:s}&#39;.format(dir_))

        try:
            if (absolute_dir ==
                    ServerCodeGenerator._normalize_filename(server_dir)):
                raise ValueError(
                    &#39;The client code directory may not be the same as the &#39;
                    &#39;server code directory&#39;)
        except OSError:
            pass

        parent = os.path.dirname(absolute_dir)
        try:
            if parent == ServerCodeGenerator._normalize_filename(server_dir):
                return
        except OSError:
            pass

        if not os.path.isdir(parent):
            raise ValueError(
                &#39;The parent folder {:s} does not exist&#39;.format(parent))

    @staticmethod
    def _validate_url(url):
        &#34;&#34;&#34;Validate the server URL.

        Raise a ``ValueError`` if the specified user entry is not a
        valid server URL.

        Arguments:
            url (str): The user entry.
        &#34;&#34;&#34;
        scheme = urlparse(url).scheme
        if scheme == &#39;https&#39;:
            raise ValueError(
                &#39;The URL must begin with http://. HTTPS is currently not &#39;
                &#39;supported.&#39;)
        elif scheme != &#39;http&#39;:
            raise ValueError(&#39;The URL must begin with http://&#39;)

    @staticmethod
    def _validate_non_empty(value):
        &#34;&#34;&#34;Validate an input that may not be empty.

        Raise a ``ValueError`` if the specified user entry is the empty
        string.

        Arguments:
            value (str): The user entry.
        &#34;&#34;&#34;
        if not value:
            raise ValueError(&#39;Please enter a value&#39;)

    @staticmethod
    def _validate_rotation(rotation_str):
        &#34;&#34;&#34;Validate the rotation.

        Raise a ``ValueError`` if the specified user entry is not a
        valid device rotation.

        Arguments:
            rotation_str (str): The user entry.
        &#34;&#34;&#34;
        if rotation_str not in [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]:
            raise ValueError(&#39;The rotation must be 1 - 4&#39;)

    @staticmethod
    def _validate_positive_int(value):
        &#34;&#34;&#34;Validate a positive integer.

        Raise a ``ValueError`` if the specified user entry is not a
        positive integer.

        Arguments:
            value (str): The user entry.
        &#34;&#34;&#34;
        if not re.search(r&#39;^[1-9]\d*$&#39;, value):
            raise ValueError(&#39;Please enter a positive integer&#39;)

    @staticmethod
    def _local_ip_address():
        &#34;&#34;&#34;Return the device&#39;s local IP address, e.g. ``&#39;192.168.1.70&#39;``.&#34;&#34;&#34;
        # Based on https://stackoverflow.com/a/28950776/10935386
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            # Doesn&#39;t even have to be reachable
            s.connect((&#39;10.255.255.255&#39;, 1))
            return s.getsockname()[0]
        except InterruptedError:
            return &#39;127.0.0.1&#39;
        finally:
            s.close()

    @staticmethod
    def _ssid():
        &#34;&#34;&#34;Return the SSID for the Wi-Fi network we are connected to, if any.

        Return ``None`` if we were unable to determine the SSID.
        &#34;&#34;&#34;
        if os.name == &#39;nt&#39; or sys.platform == &#39;darwin&#39;:
            if os.name == &#39;nt&#39;:
                command = [&#39;Netsh&#39;, &#39;WLAN&#39;, &#39;show&#39;, &#39;interfaces&#39;]
            else:
                command = [
                    &#39;/System/Library/PrivateFrameworks/Apple80211.framework/&#39;
                    &#39;Resources/airport&#39;,
                    &#39;-I&#39;]

            try:
                output = subprocess.check_output(command).decode()
            except (
                    OSError, subprocess.CalledProcessError,
                    UnicodeDecodeError):
                return None
            for line in output.split(&#39;\n&#39;):
                stripped_line = line.strip()
                if stripped_line.startswith(&#39;SSID&#39;):
                    index = stripped_line.index(&#39;:&#39;)
                    return stripped_line[index + 2:]
            return None
        else:
            try:
                output = subprocess.check_output([
                    &#39;/sbin/iwgetid&#39;, &#39;-r&#39;]).decode()
            except (
                    OSError, subprocess.CalledProcessError,
                    UnicodeDecodeError):
                return None
            ssid = output.rstrip(&#39;\n&#39;)
            if ssid:
                return ssid
            else:
                return None

    @staticmethod
    def _input_skeleton_params():
        &#34;&#34;&#34;Prompt the user for all of the parameters to ``_gen_skeleton``.

        The return value is a tuple with all of those parameters, in
        order.
        &#34;&#34;&#34;
        local_ip_address = ServerCodeGenerator._local_ip_address()
        connected_ssid = ServerCodeGenerator._ssid()
        if os.name == &#39;nt&#39;:
            default_server_dir = os.path.join(
                os.path.expanduser(&#39;~&#39;), &#39;Documents&#39;, &#39;eink_server&#39;)
        else:
            default_server_dir = os.path.join(&#39;~&#39;, &#39;eink_server&#39;)

        server_dir = ServerCodeGenerator._input(
            &#39;Directory for the server code&#39;, default_server_dir,
            ServerCodeGenerator._validate_server_dir)
        client_dir = ServerCodeGenerator._input(
            &#39;Directory for the client code&#39;,
            os.path.join(server_dir, &#39;client&#39;),
            functools.partial(
                ServerCodeGenerator._validate_client_dir, server_dir))
        url = ServerCodeGenerator._input(
            &#39;Server URL&#39;,
            &#39;http://{:s}:5000/eink_server&#39;.format(local_ip_address),
            ServerCodeGenerator._validate_url)
        ssid = ServerCodeGenerator._input(
            &#39;Wi-Fi SSID for device to connect to&#39;, connected_ssid,
            ServerCodeGenerator._validate_non_empty)
        wi_fi_password = ServerCodeGenerator._input(
            &#39;Password for Wi-Fi (leave blank if none)&#39;, None, None, True)

        rotation_str = ServerCodeGenerator._input(
            &#39;Device rotation:\n&#39;
            &#39;1) Portrait right (bottom of device on right)\n&#39;
            &#39;2) Landscape upside down\n&#39;
            &#39;3) Portrait left (bottom of device on left)\n&#39;
            &#39;4) Landscape\n&#39;,
            &#39;4&#39;, ServerCodeGenerator._validate_rotation)

        default_width = &#39;800&#39;
        default_height = &#39;600&#39;
        if (rotation_str == str(Rotation.LANDSCAPE.value) or
                rotation_str == str(Rotation.LANDSCAPE_UPSIDE_DOWN.value)):
            width_prompt = &#39;Device width in pixels&#39;
            height_prompt = &#39;Device height in pixels&#39;
        else:
            width_prompt = &#39;Device width in pixels, after rotation&#39;
            height_prompt = &#39;Device height in pixels, after rotation&#39;
            default_width, default_height = default_height, default_width
        width = ServerCodeGenerator._input(
            width_prompt, default_width,
            ServerCodeGenerator._validate_positive_int)
        height = ServerCodeGenerator._input(
            height_prompt, default_height,
            ServerCodeGenerator._validate_positive_int)
        return (
            server_dir, client_dir, url, ssid, wi_fi_password, rotation_str,
            width, height)

    @staticmethod
    def _eval_template(server_dir, filename, params):
        &#34;&#34;&#34;Evaluate a source code template.

        This reads the template at
        assets/server_skeleton/[filename].tpl, performs string
        substitutions using ``string.Template.substitute(params)``, and
        stores the result in [server_dir]/[filename].

        Arguments:
            server_dir (str): The directory in which to store the
                resulting file.
            filename (str): The filename of the resulting file,
                excluding the directory.
            params (dict&lt;str, str&gt;): The parameters to the template.
        &#34;&#34;&#34;
        input_filename = os.path.join(
            Project.server_skeleton_dir(), &#39;{:s}.tpl&#39;.format(filename))
        with open(input_filename, &#39;r&#39;) as file:
            template = file.read()

        contents = string.Template(template).substitute(params)
        output_filename = os.path.join(server_dir, filename)
        with open(output_filename, &#39;w&#39;) as file:
            file.write(contents)

    @staticmethod
    def _write_gen_client_code(
            server_dir, client_dir, url, ssid, wi_fi_password, rotation):
        &#34;&#34;&#34;Write the contents of the gen_client_code.py file.

        This contains code for generating the client&#39;s source code.

        Arguments:
            server_dir (str): The directory in which to store the
                resulting file.
            client_dir (str): The directory in which the client code is
                stored.
            url (str): The server&#39;s URL.
            ssid (str): The SSID of the Wi-Fi network that the client
                should connect to.
            wi_fi_password (str): The password of the Wi-Fi network that
                the client should connect to. If this is ``&#39;&#39;``, then
                there is no password.
            rotation (Rotation): The rotation to use when drawing to the
                Inkplate device.
        &#34;&#34;&#34;
        import_os = &#39;&#39;
        import_separator = &#39;&#39;
        if not wi_fi_password:
            wi_fi_password_code = &#39;None&#39;
            import_json = &#39;&#39;
            read_secrets = &#39;&#39;
        else:
            wi_fi_password_code = &#34;_read_secrets()[&#39;wiFiPassword&#39;]&#34;
            import_json = &#39;\nimport json&#39;
            import_os = &#39;\nimport os&#39;
            import_separator = &#39;\n&#39;
            read_secrets = (
                &#39;\ndef _read_secrets():\n&#39;
                &#39;    &#34;&#34;&#34;Return the JSON value stored in &#39;
                &#39;assets/secrets.json.&#34;&#34;&#34;\n&#39;
                &#39;    project_dir = &#39;
                &#39;os.path.dirname(os.path.abspath(__file__))\n&#39;
                &#39;    secrets_filename = &#39;
                &#34;os.path.join(project_dir, &#39;assets&#39;, &#39;secrets.json&#39;)\n&#34;
                &#34;    with open(secrets_filename, &#39;r&#39;) as file:\n&#34;
                &#39;        return json.load(file)\n\n&#39;)

        if rotation == Rotation.LANDSCAPE:
            set_rotation = &#39;&#39;
            import_rotation = &#39;&#39;
        else:
            set_rotation = &#39;\n    config.set_rotation(Rotation.{:s})&#39;.format(
                rotation.name)
            import_rotation = &#39;from eink.generate import Rotation\n&#39;

        if os.path.dirname(client_dir) != server_dir:
            set_client_dir = &#39;    dir_ = {:s}&#39;.format(repr(client_dir))
        else:
            set_client_dir = (
                &#39;    project_dir = &#39;
                &#39;os.path.dirname(os.path.abspath(__file__))\n&#39;
                &#39;    dir_ = os.path.join(project_dir, {:s})&#39;.format(
                    repr(os.path.basename(client_dir))))
            import_os = &#39;\nimport os&#39;
            import_separator = &#39;\n&#39;

        ServerCodeGenerator._eval_template(
            server_dir, &#39;gen_client_code.py&#39;, {
                &#39;import_json&#39;: import_json,
                &#39;import_os&#39;: import_os,
                &#39;import_rotation&#39;: import_rotation,
                &#39;import_separator&#39;: import_separator,
                &#39;read_secrets&#39;: read_secrets,
                &#39;set_client_dir&#39;: set_client_dir,
                &#39;set_rotation&#39;: set_rotation,
                &#39;ssid&#39;: repr(ssid),
                &#39;url&#39;: repr(url),
                &#39;wi_fi_password&#39;: wi_fi_password_code,
            })

    @staticmethod
    def _gen_client_code(
            client_dir, url, ssid, wi_fi_password, rotation, width, height):
        &#34;&#34;&#34;Generate the client code for the skeleton.

        Arguments:
            client_dir (str): The directory in which to store the client
                code.
            url (str): The server&#39;s URL.
            ssid (str): The SSID of the Wi-Fi network that the client
                should connect to.
            wi_fi_password (str): The password of the Wi-Fi network that
                the client should connect to. If this is ``&#39;&#39;``, then
                there is no password.
            rotation (Rotation): The rotation to use when drawing to the
                Inkplate device.
            width (str): The width of the Inkplate device, as a string,
                after applying the rotation suggested by ``rotation``.
            height (str): The height of the Inkplate device, as a
                string, after applying the rotation suggested by
                ``rotation``.
        &#34;&#34;&#34;
        status_images = StatusImages.create_default(int(width), int(height))
        config = ClientConfig(WebTransport(url), status_images)
        if wi_fi_password:
            config.add_wi_fi_network(ssid, wi_fi_password)
        else:
            config.add_wi_fi_network(ssid, None)
        config.set_rotation(rotation)
        ClientCodeGenerator.gen(config, client_dir)

    @staticmethod
    def _gen_skeleton(
            server_dir, client_dir, url, ssid, wi_fi_password, rotation_str,
            width, height):
        &#34;&#34;&#34;Generate a skeleton server.

        Arguments:
            server_dir (str): The directory in which to store the
                server.
            client_dir (str): The directory in which to store the client
                code.
            url (str): The server&#39;s URL.
            ssid (str): The SSID of the Wi-Fi network that the client
                should connect to.
            wi_fi_password (str): The password of the Wi-Fi network that
                the client should connect to. If this is ``&#39;&#39;``, then
                there is no password.
            rotation_str (str): The rotation to use when drawing to the
                Inkplate device. This is the string representation of
                the value of the relevant ``Rotation``.
            width (str): The width of the Inkplate device, as a string,
                after applying the rotation suggested by
                ``rotation_str``.
            height (str): The height of the Inkplate device, as a
                string, after applying the rotation suggested by
                ``rotation_str``.
        &#34;&#34;&#34;
        server_dir = ServerCodeGenerator._normalize_filename(server_dir)
        assets_dir = os.path.join(server_dir, &#39;assets&#39;)
        client_dir = ServerCodeGenerator._normalize_filename(client_dir)
        if not os.path.exists(server_dir):
            os.mkdir(server_dir)
        if not os.path.exists(assets_dir):
            os.mkdir(assets_dir)
        if not os.path.exists(client_dir):
            os.mkdir(client_dir)

        ServerCodeGenerator._eval_template(
            server_dir, &#39;my_server.py&#39;, {
                &#39;height&#39;: height,
                &#39;width&#39;: width,
            })

        parsed_url = urlparse(url)
        if parsed_url.path:
            path = parsed_url.path
        else:
            path = &#39;/&#39;
        ServerCodeGenerator._eval_template(
            server_dir, &#39;app.py&#39;, {&#39;path&#39;: repr(path)})

        shutil.copy(
            os.path.join(Project.server_skeleton_dir(), &#39;requirements.txt&#39;),
            os.path.join(server_dir, &#39;requirements.txt&#39;))
        shutil.copy(
            os.path.join(Project.server_skeleton_dir(), &#39;GentiumPlus-R.ttf&#39;),
            os.path.join(assets_dir, &#39;GentiumPlus-R.ttf&#39;))
        shutil.copy(
            os.path.join(Project.server_skeleton_dir(), &#39;OFL.txt&#39;),
            os.path.join(assets_dir, &#39;OFL.txt&#39;))

        if wi_fi_password:
            secrets = {&#39;wiFiPassword&#39;: wi_fi_password}
            with open(os.path.join(assets_dir, &#39;secrets.json&#39;), &#39;w&#39;) as file:
                file.write(json.dumps(secrets, indent=4))
                file.write(&#39;\n&#39;)

        rotation = Rotation(int(rotation_str))
        ServerCodeGenerator._write_gen_client_code(
            server_dir, client_dir, url, ssid, wi_fi_password, rotation)
        ServerCodeGenerator._gen_client_code(
            client_dir, url, ssid, wi_fi_password, rotation, width, height)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="eink.generate.ServerCodeGenerator.gen_skeleton"><code class="name flex">
<span>def <span class="ident">gen_skeleton</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate skeleton code for an e-ink server.</p>
<p>We request information about the server using standard input and
output.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def gen_skeleton():
    &#34;&#34;&#34;Generate skeleton code for an e-ink server.

    We request information about the server using standard input and
    output.
    &#34;&#34;&#34;
    ServerCodeGenerator._gen_skeleton(
        *ServerCodeGenerator._input_skeleton_params())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eink.generate.StatusImages"><code class="flex name class">
<span>class <span class="ident">StatusImages</span></span>
<span>(</span><span>width, height)</span>
</code></dt>
<dd>
<section class="desc"><p>Describes the program's "status images."</p>
<p>A "status image" is a special full-screen image that is not produced
by <code>Server.render()</code>. It is hardcoded as part of the software on
the client device, so that the client can render it without
contacting the server. There are three types of status images: the
initial image, the low battery image, and the screensaver. Each
status image is identified by a string name.</p>
<p>Initialize a new <code>StatusImages</code> object.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>The width of the Inkplate display, after
rotation (as in <code>ClientConfig.set_rotation</code>).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>The height of the Inkplate display, after
rotation (as in <code>ClientConfig.set_rotation</code>).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatusImages:
    &#34;&#34;&#34;Describes the program&#39;s &#34;status images.&#34;

    A &#34;status image&#34; is a special full-screen image that is not produced
    by ``Server.render()``. It is hardcoded as part of the software on
    the client device, so that the client can render it without
    contacting the server. There are three types of status images: the
    initial image, the low battery image, and the screensaver. Each
    status image is identified by a string name.
    &#34;&#34;&#34;

    # Private attributes:
    #
    # int _height - The height of the Inkplate display, after rotation (as in
    #     ClientConfig.set_rotation).
    # dict&lt;str, Image&gt; _images - A map from the names of the status images to
    #     the images.
    # str _initial_image_name - The name of the status image to display when
    #     the device is turned on.
    # str _low_battery_image_name - The name of the status image to display if
    #     the device is low on battery. When this happens, we stop trying to
    #     connect to the server.
    # dict&lt;str, int&gt; _quality - A map from the names of the status images to
    #     their qualities, as in the &#34;quality&#34; argument to set_image.
    # int _width - The width of the Inkplate display, after rotation (as in
    #     ClientConfig.set_rotation).

    def __init__(self, width, height):
        &#34;&#34;&#34;Initialize a new ``StatusImages`` object.

        Arguments:
            width (int): The width of the Inkplate display, after
                rotation (as in ``ClientConfig.set_rotation``).
            height (int): The height of the Inkplate display, after
                rotation (as in ``ClientConfig.set_rotation``).
        &#34;&#34;&#34;
        self._width = width
        self._height = height
        self._images = {}
        self._quality = {}
        self._initial_image_name = &#39;connecting&#39;
        self._low_battery_image_name = &#39;low_battery&#39;

    def set_image(self, name, image, quality=100):
        &#34;&#34;&#34;Set (or add) the status image with the specified name.

        We automatically convert the image to a 3-bit grayscale image
        using ``EinkGraphics.round``.

        Arguments:
            name (str): The name of the status image.
            image (Image): The status image. This must be the same size
                as the display.
            quality (int): The compression quality to use to store the
                image. This is a number from 0 to 100, as in the JPEG
                file format. The higher the number, the more faithfully
                we will be able to reproduce the image, but the more
                memory it will require. 100 indicates perfect quality
                (or lossless).

                Normally, a quality of 100 is recommended. But if the
                status images are too numerous and large, it&#39;s possible
                that they won&#39;t fit in the client&#39;s program memory. In
                that case, a lower level of quality is required.
        &#34;&#34;&#34;
        if image.width != self._width or image.height != self._height:
            raise ValueError(
                &#39;A status image must be the same size as the display&#39;)
        self._images[name] = image
        self._quality[name] = quality

    def set_initial_image_name(self, name):
        &#34;&#34;&#34;Set the name of the initial status image.

        Set the name of the status image to display when the device is
        turned on. The default is ``&#39;connecting&#39;``.
        &#34;&#34;&#34;
        self._initial_image_name = name

    def set_low_battery_image_name(self, name):
        &#34;&#34;&#34;Set the name of the low battery image.

        Set the name of the status image to display if the device is low
        on battery. When this happens, we stop trying to connect to the
        server. The default low battery image name is ``&#39;low_battery&#39;``.
        &#34;&#34;&#34;
        self._low_battery_image_name = name

    def default_initial_image(self):
        &#34;&#34;&#34;Return the &#34;default&#34; initial status image.

        Return the &#34;default&#34; status image to display when the display is
        turned on. This is a standard image that the ``eink-server``
        library provides as a default.

        Returns:
            Image: The image.
        &#34;&#34;&#34;
        return self._default_image(&#39;connecting.png&#39;)

    def default_low_battery_image(self):
        &#34;&#34;&#34;Return the &#34;default&#34; low battery image.

        Return the &#34;default&#34; status image to display if the device is
        low on battery. This is a standard image that the
        ``eink-server`` library provides as a default.

        Returns:
            Image: The image.
        &#34;&#34;&#34;
        return self._default_image(&#39;low_battery.png&#39;)

    @staticmethod
    def create_default(width, height):
        &#34;&#34;&#34;Return an instance of ``StatusImages`` with &#34;default&#34; images.

        This uses standard images that the ``eink-server`` library
        provides as defaults. It uses the default image names.

        Arguments:
            width (int): The width of the Inkplate display, after
                rotation (as in ``ClientConfig.set_rotation``).
            height (int): The height of the Inkplate display, after
                rotation (as in ``ClientConfig.set_rotation``).
        &#34;&#34;&#34;
        images = StatusImages(width, height)
        images.set_image(&#39;connecting&#39;, images.default_initial_image())
        images.set_image(&#39;low_battery&#39;, images.default_low_battery_image())
        return images

    def _default_image(self, filename):
        &#34;&#34;&#34;Return a default status image from the specified image file.

        Arguments:
            filename (str): The filename of the image file, excluding
                the directory (``Project.images_dir()``).

        Returns:
            Image: The image.
        &#34;&#34;&#34;
        image = Image.open(os.path.join(Project.images_dir(), filename))
        output = Image.new(&#39;L&#39;, (self._width, self._height), 255)
        output.paste(
            image, (
                (self._width - image.width) // 2,
                (self._height - image.height) // 2))
        return output</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="eink.generate.StatusImages.create_default"><code class="name flex">
<span>def <span class="ident">create_default</span></span>(<span>width, height)</span>
</code></dt>
<dd>
<section class="desc"><p>Return an instance of <code>StatusImages</code> with "default" images.</p>
<p>This uses standard images that the <code>eink-server</code> library
provides as defaults. It uses the default image names.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>The width of the Inkplate display, after
rotation (as in <code>ClientConfig.set_rotation</code>).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>The height of the Inkplate display, after
rotation (as in <code>ClientConfig.set_rotation</code>).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_default(width, height):
    &#34;&#34;&#34;Return an instance of ``StatusImages`` with &#34;default&#34; images.

    This uses standard images that the ``eink-server`` library
    provides as defaults. It uses the default image names.

    Arguments:
        width (int): The width of the Inkplate display, after
            rotation (as in ``ClientConfig.set_rotation``).
        height (int): The height of the Inkplate display, after
            rotation (as in ``ClientConfig.set_rotation``).
    &#34;&#34;&#34;
    images = StatusImages(width, height)
    images.set_image(&#39;connecting&#39;, images.default_initial_image())
    images.set_image(&#39;low_battery&#39;, images.default_low_battery_image())
    return images</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eink.generate.StatusImages.default_initial_image"><code class="name flex">
<span>def <span class="ident">default_initial_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the "default" initial status image.</p>
<p>Return the "default" status image to display when the display is
turned on. This is a standard image that the <code>eink-server</code>
library provides as a default.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Image</code></strong></dt>
<dd>The image.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_initial_image(self):
    &#34;&#34;&#34;Return the &#34;default&#34; initial status image.

    Return the &#34;default&#34; status image to display when the display is
    turned on. This is a standard image that the ``eink-server``
    library provides as a default.

    Returns:
        Image: The image.
    &#34;&#34;&#34;
    return self._default_image(&#39;connecting.png&#39;)</code></pre>
</details>
</dd>
<dt id="eink.generate.StatusImages.default_low_battery_image"><code class="name flex">
<span>def <span class="ident">default_low_battery_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the "default" low battery image.</p>
<p>Return the "default" status image to display if the device is
low on battery. This is a standard image that the
<code>eink-server</code> library provides as a default.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Image</code></strong></dt>
<dd>The image.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_low_battery_image(self):
    &#34;&#34;&#34;Return the &#34;default&#34; low battery image.

    Return the &#34;default&#34; status image to display if the device is
    low on battery. This is a standard image that the
    ``eink-server`` library provides as a default.

    Returns:
        Image: The image.
    &#34;&#34;&#34;
    return self._default_image(&#39;low_battery.png&#39;)</code></pre>
</details>
</dd>
<dt id="eink.generate.StatusImages.set_image"><code class="name flex">
<span>def <span class="ident">set_image</span></span>(<span>self, name, image, quality=100)</span>
</code></dt>
<dd>
<section class="desc"><p>Set (or add) the status image with the specified name.</p>
<p>We automatically convert the image to a 3-bit grayscale image
using <code>EinkGraphics.round</code>.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the status image.</dd>
<dt><strong><code>image</code></strong> :&ensp;<code>Image</code></dt>
<dd>The status image. This must be the same size
as the display.</dd>
<dt><strong><code>quality</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>The compression quality to use to store the
image. This is a number from 0 to 100, as in the JPEG
file format. The higher the number, the more faithfully
we will be able to reproduce the image, but the more
memory it will require. 100 indicates perfect quality
(or lossless).</p>
<p>Normally, a quality of 100 is recommended. But if the
status images are too numerous and large, it's possible
that they won't fit in the client's program memory. In
that case, a lower level of quality is required.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image(self, name, image, quality=100):
    &#34;&#34;&#34;Set (or add) the status image with the specified name.

    We automatically convert the image to a 3-bit grayscale image
    using ``EinkGraphics.round``.

    Arguments:
        name (str): The name of the status image.
        image (Image): The status image. This must be the same size
            as the display.
        quality (int): The compression quality to use to store the
            image. This is a number from 0 to 100, as in the JPEG
            file format. The higher the number, the more faithfully
            we will be able to reproduce the image, but the more
            memory it will require. 100 indicates perfect quality
            (or lossless).

            Normally, a quality of 100 is recommended. But if the
            status images are too numerous and large, it&#39;s possible
            that they won&#39;t fit in the client&#39;s program memory. In
            that case, a lower level of quality is required.
    &#34;&#34;&#34;
    if image.width != self._width or image.height != self._height:
        raise ValueError(
            &#39;A status image must be the same size as the display&#39;)
    self._images[name] = image
    self._quality[name] = quality</code></pre>
</details>
</dd>
<dt id="eink.generate.StatusImages.set_initial_image_name"><code class="name flex">
<span>def <span class="ident">set_initial_image_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the name of the initial status image.</p>
<p>Set the name of the status image to display when the device is
turned on. The default is <code>'connecting'</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_initial_image_name(self, name):
    &#34;&#34;&#34;Set the name of the initial status image.

    Set the name of the status image to display when the device is
    turned on. The default is ``&#39;connecting&#39;``.
    &#34;&#34;&#34;
    self._initial_image_name = name</code></pre>
</details>
</dd>
<dt id="eink.generate.StatusImages.set_low_battery_image_name"><code class="name flex">
<span>def <span class="ident">set_low_battery_image_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the name of the low battery image.</p>
<p>Set the name of the status image to display if the device is low
on battery. When this happens, we stop trying to connect to the
server. The default low battery image name is <code>'low_battery'</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_low_battery_image_name(self, name):
    &#34;&#34;&#34;Set the name of the low battery image.

    Set the name of the status image to display if the device is low
    on battery. When this happens, we stop trying to connect to the
    server. The default low battery image name is ``&#39;low_battery&#39;``.
    &#34;&#34;&#34;
    self._low_battery_image_name = name</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="eink.generate.Transport"><code class="flex name class">
<span>class <span class="ident">Transport</span></span>
</code></dt>
<dd>
<section class="desc"><p>A transport mechanism for the client to communicate with a server.</p>
<p>This is an abstract base class. For now, the only subclass is
<code>WebTransport</code>, but we could imagine adding <code>BluetoothTransport</code>
or <code>SerialTransport</code> in the future.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transport:
    &#34;&#34;&#34;A transport mechanism for the client to communicate with a server.

    This is an abstract base class. For now, the only subclass is
    ``WebTransport``, but we could imagine adding ``BluetoothTransport``
    or ``SerialTransport`` in the future.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eink.generate.web_transport.WebTransport" href="web_transport.html#eink.generate.web_transport.WebTransport">WebTransport</a></li>
</ul>
</dd>
<dt id="eink.generate.WebTransport"><code class="flex name class">
<span>class <span class="ident">WebTransport</span></span>
<span>(</span><span>url)</span>
</code></dt>
<dd>
<section class="desc"><p>A <code>Transport</code> for connecting to a web server.</p>
<p>Each request is submitted as a POST request to a given URL, with the
request payload as the POST body. The response is returned in the
response payload.</p>
<p>Initialize a new <code>WebTransport</code>.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The server URL.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WebTransport(Transport):
    &#34;&#34;&#34;A ``Transport`` for connecting to a web server.

    Each request is submitted as a POST request to a given URL, with the
    request payload as the POST body. The response is returned in the
    response payload.
    &#34;&#34;&#34;

    # Private attributes:
    #
    # str _url - The server URL.

    def __init__(self, url):
        &#34;&#34;&#34;Initialize a new ``WebTransport``.

        Arguments:
            url (str): The server URL.
        &#34;&#34;&#34;
        self._url = url</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eink.generate.transport.Transport" href="transport.html#eink.generate.transport.Transport">Transport</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eink" href="../index.html">eink</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="eink.generate.client_code_generator" href="client_code_generator.html">eink.generate.client_code_generator</a></code></li>
<li><code><a title="eink.generate.client_config" href="client_config.html">eink.generate.client_config</a></code></li>
<li><code><a title="eink.generate.rotation" href="rotation.html">eink.generate.rotation</a></code></li>
<li><code><a title="eink.generate.server_code_generator" href="server_code_generator.html">eink.generate.server_code_generator</a></code></li>
<li><code><a title="eink.generate.status_images" href="status_images.html">eink.generate.status_images</a></code></li>
<li><code><a title="eink.generate.transport" href="transport.html">eink.generate.transport</a></code></li>
<li><code><a title="eink.generate.web_transport" href="web_transport.html">eink.generate.web_transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eink.generate.ClientCodeGenerator" href="#eink.generate.ClientCodeGenerator">ClientCodeGenerator</a></code></h4>
<ul class="">
<li><code><a title="eink.generate.ClientCodeGenerator.gen" href="#eink.generate.ClientCodeGenerator.gen">gen</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eink.generate.ClientConfig" href="#eink.generate.ClientConfig">ClientConfig</a></code></h4>
<ul class="">
<li><code><a title="eink.generate.ClientConfig.add_wi_fi_network" href="#eink.generate.ClientConfig.add_wi_fi_network">add_wi_fi_network</a></code></li>
<li><code><a title="eink.generate.ClientConfig.set_rotation" href="#eink.generate.ClientConfig.set_rotation">set_rotation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eink.generate.Rotation" href="#eink.generate.Rotation">Rotation</a></code></h4>
<ul class="">
<li><code><a title="eink.generate.Rotation.LANDSCAPE" href="#eink.generate.Rotation.LANDSCAPE">LANDSCAPE</a></code></li>
<li><code><a title="eink.generate.Rotation.LANDSCAPE_UPSIDE_DOWN" href="#eink.generate.Rotation.LANDSCAPE_UPSIDE_DOWN">LANDSCAPE_UPSIDE_DOWN</a></code></li>
<li><code><a title="eink.generate.Rotation.PORTRAIT_LEFT" href="#eink.generate.Rotation.PORTRAIT_LEFT">PORTRAIT_LEFT</a></code></li>
<li><code><a title="eink.generate.Rotation.PORTRAIT_RIGHT" href="#eink.generate.Rotation.PORTRAIT_RIGHT">PORTRAIT_RIGHT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eink.generate.ServerCodeGenerator" href="#eink.generate.ServerCodeGenerator">ServerCodeGenerator</a></code></h4>
<ul class="">
<li><code><a title="eink.generate.ServerCodeGenerator.gen_skeleton" href="#eink.generate.ServerCodeGenerator.gen_skeleton">gen_skeleton</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eink.generate.StatusImages" href="#eink.generate.StatusImages">StatusImages</a></code></h4>
<ul class="">
<li><code><a title="eink.generate.StatusImages.create_default" href="#eink.generate.StatusImages.create_default">create_default</a></code></li>
<li><code><a title="eink.generate.StatusImages.default_initial_image" href="#eink.generate.StatusImages.default_initial_image">default_initial_image</a></code></li>
<li><code><a title="eink.generate.StatusImages.default_low_battery_image" href="#eink.generate.StatusImages.default_low_battery_image">default_low_battery_image</a></code></li>
<li><code><a title="eink.generate.StatusImages.set_image" href="#eink.generate.StatusImages.set_image">set_image</a></code></li>
<li><code><a title="eink.generate.StatusImages.set_initial_image_name" href="#eink.generate.StatusImages.set_initial_image_name">set_initial_image_name</a></code></li>
<li><code><a title="eink.generate.StatusImages.set_low_battery_image_name" href="#eink.generate.StatusImages.set_low_battery_image_name">set_low_battery_image_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="eink.generate.Transport" href="#eink.generate.Transport">Transport</a></code></h4>
</li>
<li>
<h4><code><a title="eink.generate.WebTransport" href="#eink.generate.WebTransport">WebTransport</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>